<!doctype html><html><head><title>Soul Gateway Learns WebSocket Data Synchronization Analysis · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="en"</script><script src=/js/app.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?a02cb5c75097762223d5a815a03e0a15";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/><img class=logo src=/img/logo/dromara.jpg></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/><span>Projects</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/guides/><span>Guides</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/><span>Blog</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/activities/><span>Activity</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/><span>Community</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/soul_source_learning_10_websocket/><span>中文</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/>Projects</a>
<a class=navbar-item href=/guides/>Guides</a>
<a class=navbar-item href=/blog/>Blog</a>
<a class=navbar-item href=/activities/>Activity</a>
<a class=navbar-item href=/community/>Community</a>
<a class=navbar-item href=/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/zh/blog/soul_source_learning_10_websocket/>中</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Soul Gateway Learns WebSocket Data Synchronization Analysis</h1><div class=meta>2021-01-22 ·
fanjinpeng,zhuming ·
<span class=tags><a class=tag href=/tags/soul/ rel=tag>#Soul</a></span></div></div><article class=typo><blockquote><p>Fanjinpeng</p></blockquote><h1 id=1-前情回顾>1.前情回顾</h1><p>在第4篇中，我们分析了 HTTP 用户业务系统接入 Soul 网关后，会调用 soul-admin 的注册接口，把需要网关代理的接口信息全部注册到 soul-admin 上，在最后，会通过 websocket 长连接，将soul-admin 接收到的接口信息同步给 Soul 网关（即 soul-bootstrap），今天就来接着继续分析，数据是怎么同步到 soul-bootstrap 的。</p><p>不清楚流程的可以出门左转看下第4篇文章 <a href=https://blog.csdn.net/hellboy0621/article/details/112727101>【Soul源码阅读】4.HTTP 用户接入 Soul 调用 /soul-client/springmvc-register 接口逻辑分析</a></p><h1 id=2-soul-admin-与-soul-bootstrap-数据同步>2.soul-admin 与 soul-bootstrap 数据同步</h1><p>这里为了验证数据同步流程，其实也没必要非得启动业务系统，完全可以只启动 soul-admin 和 soul-bootstrap 两个系统即可，可以在页面打开或关闭插件，看看这个流程是怎么实现的。</p><p>数据同步策略官网链接 <a href=https://dromara.org/zh-cn/docs/soul/user-dataSync.html>https://dromara.org/zh-cn/docs/soul/user-dataSync.html</a></p><h2 id=2-1-启动2个系统>2.1 启动2个系统</h2><p>都是按照项目默认启动的，无需修改任何配置文件。</p><h2 id=2-2-页面操作查找接口>2.2 页面操作查找接口</h2><p>这里把 divide 插件启动，F12，看下前台会调用 soul-admin 哪个接口。</p><p><img src=/img/soul/blog3/open_divide_plugin.png alt=open_divide_plugin></p><p>可以看到前台向后台发送了一个 PUT 请求：<a href=http://localhost:9095/plugin/5>http://localhost:9095/plugin/5</a></p><h2 id=2-3-后台接口>2.3 后台接口</h2><p>在项目中搜索这个接口</p><pre><code class=language-java>// PluginController.java
@RestController
@RequestMapping(&quot;/plugin&quot;)
public class PluginController {
 
...
 
    /**
     * update plugin.
     *
     * @param id        primary key.
     * @param pluginDTO plugin.
     * @return {@linkplain SoulAdminResult}
     */
    @PutMapping(&quot;/{id}&quot;)
    public SoulAdminResult updatePlugin(@PathVariable(&quot;id&quot;) final String id, @RequestBody final PluginDTO pluginDTO) {
        Objects.requireNonNull(pluginDTO);
        pluginDTO.setId(id);
        final String result = pluginService.createOrUpdate(pluginDTO);
        if (StringUtils.isNoneBlank(result)) {
            return SoulAdminResult.error(result);
        }
        return SoulAdminResult.success(SoulResultMessage.UPDATE_SUCCESS);
    }
 
...
 
}
</code></pre><p>进到实现类里</p><pre><code class=language-java>// PluginServiceImpl.java
/**
     * create or update plugin.
     *
     * @param pluginDTO {@linkplain PluginDTO}
     * @return rows
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public String createOrUpdate(final PluginDTO pluginDTO) {
        final String msg = checkData(pluginDTO);
        if (StringUtils.isNoneBlank(msg)) {
            return msg;
        }
        PluginDO pluginDO = PluginDO.buildPluginDO(pluginDTO);
        DataEventTypeEnum eventType = DataEventTypeEnum.CREATE;
        if (StringUtils.isBlank(pluginDTO.getId())) {
            pluginMapper.insertSelective(pluginDO);
        } else {
            eventType = DataEventTypeEnum.UPDATE;
            pluginMapper.updateSelective(pluginDO);
        }
 
        // publish change event.
        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, eventType,
                Collections.singletonList(PluginTransfer.INSTANCE.mapToData(pluginDO))));
        return StringUtils.EMPTY;
    }
</code></pre><p>这里可以看出来，前半部分都是在操作数据库，把相关信息持久化；后半部分是发布了一个事件。</p><h2 id=2-4-发布事件>2.4 发布事件</h2><p>这里发布的事件用 DataChangedEvent 封装了一层，再看里面有1个枚举，这里有很多种类型：</p><pre><code class=language-java>/**
 * configuration group.
 *
 * @author huangxiaofeng
 */
public enum ConfigGroupEnum {
 
    APP_AUTH,
 
    PLUGIN,
 
    RULE,
 
    SELECTOR,
 
    META_DATA;
 
...
 
}
</code></pre><p>看到这几种类型，如果对第4篇还有印象的话，可以看出当时发送事件的类型就是 SELECTOR 和 RULE，现在是 PLUGIN，虽然类型不同，但不影响我们继续分析后面的逻辑，我们继续。</p><p>另外一个 eventType 也是枚举，这里有 DELETE、CREATE、UPDATE、REFRESH、MYSELF 5种类型，此时是 UPDATE。</p><pre><code class=language-java>/**
 * The enum Data event type.
 *
 * @author xiaoyu
 */
public enum DataEventTypeEnum {
    /**
     * delete event.
     */
    DELETE,
    /**
     * insert event.
     */
    CREATE,
    /**
     * update event.
     */
    UPDATE,
    /**
     * REFRESH data event type enum.
     */
    REFRESH,
    /**
     * Myself data event type enum.
     */
    MYSELF;
 
...
 
}
</code></pre><h2 id=2-5-监听事件>2.5 监听事件</h2><p>找到监听事件的代码：</p><pre><code class=language-java>// DataChangedEventDispatcher.java
@Component
public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {
 
    private ApplicationContext applicationContext;
 
    private List&lt;DataChangedListener&gt; listeners;
 
    public DataChangedEventDispatcher(final ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
 
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void onApplicationEvent(final DataChangedEvent event) {
        for (DataChangedListener listener : listeners) {
            switch (event.getGroupKey()) {
                case APP_AUTH:
                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());
                    break;
                case PLUGIN:
                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());
                    break;
                case RULE:
                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());
                    break;
                case SELECTOR:
                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());
                    break;
                case META_DATA:
                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());
                    break;
                default:
                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());
            }
        }
    }
 
    @Override
    public void afterPropertiesSet() {
        Collection&lt;DataChangedListener&gt; listenerBeans = applicationContext.getBeansOfType(DataChangedListener.class).values();
        this.listeners = Collections.unmodifiableList(new ArrayList&lt;&gt;(listenerBeans));
    }
}
</code></pre><h3 id=2-5-1-监听器注入>2.5.1 监听器注入</h3><p>可以看到 DataChangedEventDispatcher 实现了 InitializingBean 接口，覆写了 afterPropertiesSet 方法，并且使用了 @Component，当 Spring 启动时，会在容器加载完成后调用这个覆写方法。
afterPropertiesSet 方法中，把 DataChangedListener 类型的 Bean 全部获取后，放到类属性 listeners 里。</p><p>那么问题来了，这些监听器是什么时候注入到容器中的呢？</p><p>先看下 DataChangedListener 接口定义：</p><pre><code class=language-java>/**
 * Event listener, used to send notification of event changes,
 * used to support HTTP, websocket, zookeeper and other event notifications.
 *
 * @author huangxiaofeng
 * @author xiaoyu
 */
public interface DataChangedListener {
 
    /**
     * invoke this method when AppAuth was received.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onAppAuthChanged(List&lt;AppAuthData&gt; changed, DataEventTypeEnum eventType) {
    }
 
    /**
     * invoke this method when Plugin was received.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onPluginChanged(List&lt;PluginData&gt; changed, DataEventTypeEnum eventType) {
    }
 
    /**
     * invoke this method when Selector was received.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onSelectorChanged(List&lt;SelectorData&gt; changed, DataEventTypeEnum eventType) {
    }
 
    /**
     * On meta data changed.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onMetaDataChanged(List&lt;MetaData&gt; changed, DataEventTypeEnum eventType) {
 
    }
 
    /**
     * invoke this method when Rule was received.
     *
     * @param changed   the changed
     * @param eventType the event type
     */
    default void onRuleChanged(List&lt;RuleData&gt; changed, DataEventTypeEnum eventType) {
    }
 
}
</code></pre><p>可以看到接口中定义了5个方法，分别针对当监听到 appAuth、plugin、selector、metaData、rule 数据变动时对应的处理方法。</p><p>其继承关系：</p><p><img src=/img/soul/blog3/DataChangedListener.png alt=DataChangedListener></p><p>因为默认是采用的 websocket，这里的监听器对应的就是 WebsocketDataChangedListener，Alt + F7，搜索到这个类实例化的地方，就是如下的配置类：</p><pre><code class=language-java>// DataSyncConfiguration.java
@Configuration
public class DataSyncConfiguration {
 
    /**
     * http long polling.
     */
    @Configuration
    @ConditionalOnProperty(name = &quot;soul.sync.http.enabled&quot;, havingValue = &quot;true&quot;)
    @EnableConfigurationProperties(HttpSyncProperties.class)
    static class HttpLongPollingListener {
        @Bean
        @ConditionalOnMissingBean(HttpLongPollingDataChangedListener.class)
        public HttpLongPollingDataChangedListener httpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {
            return new HttpLongPollingDataChangedListener(httpSyncProperties);
        }
    }
 
    /**
     * The type Zookeeper listener.
     */
    @Configuration
    @ConditionalOnProperty(prefix = &quot;soul.sync.zookeeper&quot;, name = &quot;url&quot;)
    @Import(ZookeeperConfiguration.class)
    static class ZookeeperListener {
        @Bean
        @ConditionalOnMissingBean(ZookeeperDataChangedListener.class)
        public DataChangedListener zookeeperDataChangedListener(final ZkClient zkClient) {
            return new ZookeeperDataChangedListener(zkClient);
        }
        @Bean
        @ConditionalOnMissingBean(ZookeeperDataInit.class)
        public ZookeeperDataInit zookeeperDataInit(final ZkClient zkClient, final SyncDataService syncDataService) {
            return new ZookeeperDataInit(zkClient, syncDataService);
        }
    }
 
    /**
     * The type Nacos listener.
     */
    @Configuration
    @ConditionalOnProperty(prefix = &quot;soul.sync.nacos&quot;, name = &quot;url&quot;)
    @Import(NacosConfiguration.class)
    static class NacosListener {
        @Bean
        @ConditionalOnMissingBean(NacosDataChangedListener.class)
        public DataChangedListener nacosDataChangedListener(final ConfigService configService) {
            return new NacosDataChangedListener(configService);
        }
    }
 
    /**
     * The WebsocketListener(default strategy).
     */
    @Configuration
    @ConditionalOnProperty(name = &quot;soul.sync.websocket.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
    @EnableConfigurationProperties(WebsocketSyncProperties.class)
    static class WebsocketListener {
        @Bean
        @ConditionalOnMissingBean(WebsocketDataChangedListener.class)
        public DataChangedListener websocketDataChangedListener() {
            return new WebsocketDataChangedListener();
        }
        @Bean
        @ConditionalOnMissingBean(WebsocketCollector.class)
        public WebsocketCollector websocketCollector() {
            return new WebsocketCollector();
        }
        @Bean
        @ConditionalOnMissingBean(ServerEndpointExporter.class)
        public ServerEndpointExporter serverEndpointExporter() {
            return new ServerEndpointExporter();
        }
    }
}
</code></pre><p>一共有4种同步数据策略，http长轮询、zookeeper、nacos、websocket（默认策略）。</p><p>看到 websocket 的注解 @ConditionalOnProperty(name = &ldquo;soul.sync.websocket.enabled&rdquo;, havingValue = &ldquo;true&rdquo;, matchIfMissing = true)，到配置文件中找到如下配置：</p><pre><code class=language-yaml>soul:
  sync:
    websocket:
      enabled: true
</code></pre><p>到这里就真相大白了。</p><p>如果不想使用 websocket 的默认同步策略，在配置文件中写上对应的配置即可。</p><h3 id=2-5-2-监听事件处理逻辑>2.5.2 监听事件处理逻辑</h3><p>为了防止大家再翻回去看，不方便，我这里再把处理逻辑代码贴出来：</p><pre><code class=language-java>// DataChangedEventDispatcher.java
@Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void onApplicationEvent(final DataChangedEvent event) {
        for (DataChangedListener listener : listeners) {
            switch (event.getGroupKey()) {
                case APP_AUTH:
                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());
                    break;
                case PLUGIN:
                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());
                    break;
                case RULE:
                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());
                    break;
                case SELECTOR:
                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());
                    break;
                case META_DATA:
                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());
                    break;
                default:
                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());
            }
        }
    }
</code></pre><p>这里遍历所有的监听器，对于目前的 websocket 只会有一个监听器，其他多个的情况暂时不知道什么时候会出现，这里存疑，后续碰到相关的 case 时再回来补充（// TODO）。</p><p>根据发布事件的类型走不同的逻辑，这里分的类型跟 DataChangedListener 接口中定义的方法一一对应。</p><p>这里的 listener 是 WebsocketDataChangedListener 的实例，会进到类中对应的方法：</p><pre><code class=language-java>// WebsocketDataChangedListener.java
public class WebsocketDataChangedListener implements DataChangedListener {
 
    @Override
    public void onPluginChanged(final List&lt;PluginData&gt; pluginDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;PluginData&gt; websocketData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.PLUGIN.name(), eventType.name(), pluginDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);
    }
 
    @Override
    public void onSelectorChanged(final List&lt;SelectorData&gt; selectorDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;SelectorData&gt; websocketData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.SELECTOR.name(), eventType.name(), selectorDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);
    }
 
    @Override
    public void onRuleChanged(final List&lt;RuleData&gt; ruleDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;RuleData&gt; configData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.RULE.name(), eventType.name(), ruleDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(configData), eventType);
    }
 
    @Override
    public void onAppAuthChanged(final List&lt;AppAuthData&gt; appAuthDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;AppAuthData&gt; configData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.APP_AUTH.name(), eventType.name(), appAuthDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(configData), eventType);
    }
 
    @Override
    public void onMetaDataChanged(final List&lt;MetaData&gt; metaDataList, final DataEventTypeEnum eventType) {
        WebsocketData&lt;MetaData&gt; configData =
                new WebsocketData&lt;&gt;(ConfigGroupEnum.META_DATA.name(), eventType.name(), metaDataList);
        WebsocketCollector.send(GsonUtils.getInstance().toJson(configData), eventType);
    }
 
}
</code></pre><p>看到代码中，将数据封装为 WebsocketData 后，使用 WebsocketController.send 方法发送出去了。</p><h2 id=2-6-同步数据给-soul-bootstrap>2.6 同步数据给 soul-bootstrap</h2><pre><code class=language-java>// WebsocketCollector.java
@Slf4j
@ServerEndpoint(&quot;/websocket&quot;)
public class WebsocketCollector {
 
    private static final Set&lt;Session&gt; SESSION_SET = new CopyOnWriteArraySet&lt;&gt;();
 
    private static final String SESSION_KEY = &quot;sessionKey&quot;;
 
    /**
     * On open.
     *
     * @param session the session
     */
    @OnOpen
    public void onOpen(final Session session) {
        log.info(&quot;websocket on open successful....&quot;);
        SESSION_SET.add(session);
    }
 
    /**
     * On message.
     *
     * @param message the message
     * @param session the session
     */
    @OnMessage
    public void onMessage(final String message, final Session session) {
        if (message.equals(DataEventTypeEnum.MYSELF.name())) {
            try {
                ThreadLocalUtil.put(SESSION_KEY, session);
                SpringBeanUtils.getInstance().getBean(SyncDataService.class).syncAll(DataEventTypeEnum.MYSELF);
            } finally {
                ThreadLocalUtil.clear();
            }
        }
    }
 
    /**
     * On close.
     *
     * @param session the session
     */
    @OnClose
    public void onClose(final Session session) {
        SESSION_SET.remove(session);
        ThreadLocalUtil.clear();
    }
 
    /**
     * On error.
     *
     * @param session the session
     * @param error   the error
     */
    @OnError
    public void onError(final Session session, final Throwable error) {
        SESSION_SET.remove(session);
        ThreadLocalUtil.clear();
        log.error(&quot;websocket collection error: &quot;, error);
    }
 
    /**
     * Send.
     *
     * @param message the message
     * @param type    the type
     */
    public static void send(final String message, final DataEventTypeEnum type) {
        if (StringUtils.isNotBlank(message)) {
            if (DataEventTypeEnum.MYSELF == type) {
                try {
                    Session session = (Session) ThreadLocalUtil.get(SESSION_KEY);
                    if (session != null) {
                        session.getBasicRemote().sendText(message);
                    }
                } catch (IOException e) {
                    log.error(&quot;websocket send result is exception: &quot;, e);
                }
                return;
            }
            for (Session session : SESSION_SET) {
                try {
                    session.getBasicRemote().sendText(message);
                } catch (IOException e) {
                    log.error(&quot;websocket send result is exception: &quot;, e);
                }
            }
        }
    }
}
</code></pre><p>WebsocketController 使用了 @ServerEndpoint(&ldquo;/websocket&rdquo;) 注解，开启了一个 websocket 服务接口，等待连接。</p><p>当 soul-bootstrap 启动后，会连接这个 websocket，这时触发 onOpen 方法，将此次连接信息的 Session 存放在 SESSION_SET 这个 Set 集合里。</p><p>在 send 方法中，会先判断 DataEventTypeEnum type 是不是 MYSELF，这个 type 可以追溯到 2.3-2.4，此次是 UPDATE，关于什么时候是 MYSELF，还需要后续补充，此处存疑（// TODO）。</p><p>下面的 for 循环遍历所有的 websocket 连接 Session，发送变动数据。</p><p>到这里，默认的 websocket 同步数据策略就分析清楚了。</p><blockquote><p>Zhuming</p></blockquote><h2 id=后台与网关数据同步-websocket篇>后台与网关数据同步 (Websocket篇)</h2><h3 id=后台如何建立websocket>后台如何建立Websocket?</h3><p><img src=/img/soul/blog1/05.png alt=05>
DataSyncConfiguration: 作为 Spring Bean 的配置工厂, 可以根据配置信息, 构建各类监听器, 包括 HTTP 长轮询方式、Zookeeper 方式、Nacos 方式、Websocket 方法.</p><pre><code class=language-java>@Configuration
public class DataSyncConfiguration {
  
  // soul-admin 项目的配置信息中, 使用 soul.sync.websocket.enabled 开启或关闭 websocket
  @Configuration
  @ConditionalOnProperty(name = &quot;soul.sync.websocket.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
  @EnableConfigurationProperties(WebsocketSyncProperties.class)
  static class WebsocketListener {
    
    @Bean
    @ConditionalOnMissingBean(WebsocketCollector.class)
    public WebsocketCollector websocketCollector() {
      return new WebsocketCollector();
    }
  }
}
</code></pre><p>WebsocketListener: 作为 <code>DataSyncConfiguration</code> 的内部类, 负责 websocket 监听器初始化.
WebsocketCollector: 监听 websocket 连接及接收信息, 维护所有连接后台的 session 会话, 提供 <code>send()</code> 方法通知 session 信息.</p><h3 id=网关如何建立websocket>网关如何建立Websocket?</h3><p><img src=/img/soul/blog1/06.png alt=06></p><p>WebsocketSyncDataConfiguration: 作为 Spring Bean 的配置工厂, 是网关端构建 Websocket 通信的入口. (独立出一个启动项目 <code>soul-spring-boot-starter-sync-data-websocket</code> , 供网关自由选用)</p><pre><code class=language-java>@Configuration
@ConditionalOnClass(WebsocketSyncDataService.class)
@ConditionalOnProperty(prefix = &quot;soul.sync.websocket&quot;, name = &quot;urls&quot;)
@Slf4j
public class WebsocketSyncDataConfiguration {
  
  // 收集所有注册为 Bean 的订阅器,  如 PluginDataSubscriber、MetaDataSubscriber、AuthDataSubscriber
  @Bean
  public SyncDataService websocketSyncDataService(final ObjectProvider&lt;WebsocketConfig&gt; websocketConfig, final ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber, final ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers, final ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers) {
    log.info(&quot;you use websocket sync soul data.......&quot;);
    return new WebsocketSyncDataService(websocketConfig.getIfAvailable(WebsocketConfig::new), pluginSubscriber.getIfAvailable(), metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));
  }
  
  // soul-bootstrap 项目的配置信息中, 使用 soul.sync.websocket 配置要建立连接的后台路径
  @Bean
  @ConfigurationProperties(prefix = &quot;soul.sync.websocket&quot;)
  public WebsocketConfig websocketConfig() {
    return new WebsocketConfig();
  }
}
</code></pre><p>WebsocketSyncDataService: 获取所有注册为 Bean 的 <code>WebsocketConfig</code> 以及各种 <code>DataSubscriber</code> 订阅器, 构建实现了 <code>WebsocketClient</code> 的 <code>SoulWebsocketClient</code> 列表</p><p>SoulWebsocketClient: <code>Websocket</code> 通信类, 监听 websocket 连接及接收信息, 在接收到后台传来的信息后会通知各个订阅器.</p><pre><code class=language-java>public final class SoulWebsocketClient extends WebSocketClient {
  
  private final WebsocketDataHandler websocketDataHandler;
  
    private void handleResult(final String result) {
    WebsocketData websocketData = GsonUtils.getInstance().fromJson(result, WebsocketData.class);
    ConfigGroupEnum groupEnum = ConfigGroupEnum.acquireByName(websocketData.getGroupType());
    // 根据传入信息得到数据变更的事件类型, 如 refresh、update、delete 等
    String eventType = websocketData.getEventType();
    String json = GsonUtils.getInstance().toJson(websocketData.getData());
    websocketDataHandler.executor(groupEnum, json, eventType);
  }
}
</code></pre><p>WebsocketDataHandler: 初始化时构建各类实现 <code>AbstractDataHandler</code> 的数据处理类并缓存.</p><pre><code class=language-java>public class WebsocketDataHandler {
  
  // 缓存所有 DataHandler 数据变动处理类
  private static final EnumMap&lt;ConfigGroupEnum, DataHandler&gt; ENUM_MAP = new EnumMap&lt;&gt;(ConfigGroupEnum.class);

  public WebsocketDataHandler(final PluginDataSubscriber pluginDataSubscriber,
                              final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,
                              final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {
    ENUM_MAP.put(ConfigGroupEnum.PLUGIN, new PluginDataHandler(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.SELECTOR, new SelectorDataHandler(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.RULE, new RuleDataHandler(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.APP_AUTH, new AuthDataHandler(authDataSubscribers));
    ENUM_MAP.put(ConfigGroupEnum.META_DATA, new MetaDataHandler(metaDataSubscribers));
  }

  public void executor(final ConfigGroupEnum type, final String json, final String eventType) {
    // 根据数据变动事件类型, 调用相应的 DataHandler 数据处理类
    ENUM_MAP.get(type).handle(json, eventType);
  }
}
</code></pre><h3 id=网关数据变动调用链>网关数据变动调用链</h3><p>实现 Websocket 通信的入口类 <code>SoulWebsocketClient</code> 在接到后台通信后, 调用 <code>WebsocketDataHandler</code> 的 <code>executor()</code> 方法匹配信息类型, 并调用对应的 <code>DataHandler</code> 的 <code>handler()</code> 去处理信息.</p><p><img src=/img/soul/blog1/07.png alt=07></p><p>AbstractDataHandler: 实现 <code>handler()</code> 方法, 根据事件的类型 (如刷新、更新、创建、删除等), 调用对应事件抽象方法.</p><pre><code class=language-java>public abstract class AbstractDataHandler&lt;T&gt; implements DataHandler {

  // 根据数据的事件类型 (eventType) 分发到各自方法, 这些被调用的方法由子类实现, 因为不同类型的元数据处理类的处理方式不同
  @Override
  public void handle(final String json, final String eventType) {
    List&lt;T&gt; dataList = convert(json);
    if (CollectionUtils.isNotEmpty(dataList)) {
      DataEventTypeEnum eventTypeEnum = DataEventTypeEnum.acquireByName(eventType);
      switch (eventTypeEnum) {
        case REFRESH:
        case MYSELF:
          doRefresh(dataList);
          break;
        case UPDATE:
        case CREATE:
          doUpdate(dataList);
          break;
        case DELETE:
          doDelete(dataList);
          break;
        default:
          break;
      }
    }
  }
}
</code></pre><p>XXXDataHandler: 这里指的是 <code>AbstractDataHandler</code> 的各个实现类 (如 <code>PluginDataHandler</code> 等), 主要作用是调用其订阅器.</p><p>不同的 <code>DataHandler</code> 调用的订阅方法不同:</p><ul><li><code>PluginDataHandler</code> 会调用 <code>onSubscribe()</code> 通知插件元数据变更</li><li><code>SelectorDataHandler</code> 会调用 <code>onSelectorSubscribe()</code> 通知选择器元数据变更</li><li><code>RuleDataHandler</code> 会调用 <code>onRuleSubscribe()</code> 通知规则元数据变更</li></ul><pre><code class=language-java>@RequiredArgsConstructor
public class PluginDataHandler extends AbstractDataHandler&lt;PluginData&gt; {
  
  private final PluginDataSubscriber pluginDataSubscriber;
  
  @Override
  protected void doUpdate(final List&lt;PluginData&gt; dataList) {
    // 调用订阅器的 onSubscribe(), 发送数据对象 PluginData
    dataList.forEach(pluginDataSubscriber::onSubscribe);
  }
  
  // ...
}
</code></pre><p>CommonPluginDataSubscriber: 订阅器的 <code>onSubscribe()</code> 方法会通知到所有注入为 Bean 的 <code>PluginDataHandler</code> 类 (不要和前面的同名类混淆, 它是 <code>soul-plugin-base</code> 下的接口, 它的实现类在各个可插拔插件包)</p><p><img src=/img/soul/blog1/image-20210122172333111.png alt=image-20210122172333111></p><pre><code class=language-java>public class CommonPluginDataSubscriber implements PluginDataSubscriber {
  
  // 收集所有注册为 Bean 的数据处理器并缓存, 比如 HTTP 插件 divide 下的 DividePluginDataHandler
  private final Map&lt;String, PluginDataHandler&gt; handlerMap;
  
  // 插件元数据变动调用
  @Override
  public void onSubscribe(final PluginData pluginData) {
    BaseDataCache.getInstance().cachePluginData(pluginData);
    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.handlerPlugin(pluginData));
  }
  
  // 选择器元数据变动调用
  @Override
  public void onSelectorSubscribe(final SelectorData selectorData) {
    BaseDataCache.getInstance().cacheSelectData(selectorData);
    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));
  }
  
  // 规则元数据变动调用
  @Override
  public void onRuleSubscribe(final RuleData ruleData) {
    BaseDataCache.getInstance().cacheRuleData(ruleData);
    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.handlerRule(ruleData));
  }
}
</code></pre><h3 id=tips>TIPS</h3><p>整个大项目下存在两个同名的类 PluginDataHandler, 其中一个在项目 <code>soul-sync-data-websocket</code> 下, 用于通知插件元数据变更, 另一个在 <code>soul-plugin-base</code> 下, 用于定义各个插件的各个类型元数据更新.</p><p>总结下这两个类命名的意义, <strong><code>soul-sync-data-websocket</code> 下类名的 &ldquo;plugin&rdquo; 指元数据的类型为插件类, <code>soul-plugin-base</code> 下类名的 &ldquo;plugin&rdquo; 指继承它的子类来自与各个可插播插件, 比如divide、dubbo插件等</strong></p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/blog/soul_source_learning_15_plugin_chain/><span class=text>Prev:</span>
<span class=text>Soul Gateway Learning Plugin Chain Implementation</span></a>
<a class=link-next href=/blog/soul_source_learning_08_httplongpolling_01/><span class=text>Next:</span>
<span class=text>Soul Gateway Learns Http Long Polling Analysis 01</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>Related</h2><ul class=ss-aside-related><li><a href=/activities/dromara-cloud-native-meet/>Dromara Soul source code 01 reading sharing session 01</a></li><li><a href=/blog/soul_source_learning_15_plugin_chain/>Soul Gateway Learning Plugin Chain Implementation</a></li><li><a href=/blog/soul_source_learning_13_zookeeper_02/>Soul Gateway Learns Zookeeper Data Synchronization 02</a></li><li><a href=/blog/soul_resource_learning_07_admin/>Soul Gateway Learning Admin Source Code Analysis</a></li><li><a href=/blog/soul_source_learning_13_zookeeper_01/>Soul Gateway Learns Zookeeper Data Synchronization 01</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>Tag
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/tags/dromara/>Dromara</a></li><li class=tag><a href=/tags/gateway/>GateWay</a></li><li class=tag><a href=/tags/hmily/>hmily</a></li><li class=tag><a href=/tags/reactor/>Reactor</a></li><li class=tag><a href=/tags/soul/>Soul</a></li><li class=tag><a href=/tags/tcc/>TCC</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>Resources</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/dromara>Gitee</a></div><div class=cate><h2 class=cate-title>Get Involved</h2><a class=link href=https://github.com/dromara/soul/issues/new>Feedback</a>
<a class=link href=/community>Community</a>
<a class=link href=/blog>Blog</a></div><div class=cate><h2 class=cate-title>Document</h2><a class=link href=/projects/soul/overview/>Soul</a>
<a class=link href=/projects/hmily/overview/>Hmily</a>
<a class=link href=/projects/raincat/overview/>Raincat</a>
<a class=link href=/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>Wechat Official Account</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ Group</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>