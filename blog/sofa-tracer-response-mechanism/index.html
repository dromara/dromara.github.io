<!doctype html><html><head><title>蚂蚁金服分布式链路跟踪组件 SOFATracer 数据上报机制和源码剖析 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-142131411-1','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/><img class=logo src=/img/logo.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/guides/><span>指南</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/>项目</a>
<a class=navbar-item href=/guides/>指南</a>
<a class=navbar-item href=/blog/>博客</a>
<a class=navbar-item href=/activities/>活动</a>
<a class=navbar-item href=/community/>社区</a>
<a class=navbar-item href=/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>蚂蚁金服分布式链路跟踪组件 SOFATracer 数据上报机制和源码剖析</h1><div class=meta>2019-02-21 ·
卫恒 ·
<span class=tags><a class=tag href=/tags/sofatracer/ rel=tag>#SOFATracer</a>
<a class=tag href=/tags/sofalab/ rel=tag>#SOFALab</a>
<a class=tag href=/tags/%E5%89%96%E6%9E%90-sofatracer-%E6%A1%86%E6%9E%B6/ rel=tag>#剖析 | SOFATracer 框架</a></span></div></div><article class=typo><blockquote><p><strong>SOFA</strong> <strong>S</strong>calable <strong>O</strong>pen <strong>F</strong>inancial <strong>A</strong>rchitecture 是蚂蚁金服自主研发的金融级分布式中间件，包含了构建金融级云原生架构所需的各个组件，是在金融场景里锤炼出来的最佳实践。</p><p>SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 TraceId 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的，这些链路数据可用于故障的快速发现，服务治理等。</p><p>本文为《剖析 | SOFATracer 框架》第二篇。《剖析 | SOFATracer 框架》系列由 SOFA 团队和源码爱好者们出品，项目代号：<strong><a href=SOFA:TracerLab/>SOFA:TracerLab/</a></strong>，目前领取已经完成，感谢大家的参与。</p><p>SOFATracer：<a href=https://github.com/sofastack/sofa-tracer>https://github.com/sofastack/sofa-tracer</a></p></blockquote><p><img src=https://cdn.nlark.com/yuque/0/2019/jpeg/226702/1547173396825-f25c0dcc-19c3-424d-9830-cfc4d923e0a0.jpeg alt=SOFATracer-数据上报.jpg></p><h2 id=0-前言>0、前言</h2><p>在《<a href=https://www.sofastack.tech/blog/sofa-tracer-overview/>蚂蚁金服分布式链路跟踪组件 SOFATracer 总览|剖析</a>》一文中已经对 SOFATracer 进行了概要性的介绍。从对 SOFATracer 的定义可以了解到，SOFATracer 作为一个分布式系统调用跟踪的组件，是通过统一的 TraceId 将调用链路中的各种网络调用情况以数据上报的方式记录下来，以达到透视化网络调用的目的。</p><p>本篇将针对SOFATracer的数据上报方式进行详细分析，以帮助大家更好的理解 SOFATracer 在数据上报方面的扩展。</p><h2 id=1-reporter-整体模型>1、Reporter 整体模型</h2><p>本节将对 SOFATracer 的 Report 模型进行整体介绍，主要包括两个部分：</p><ol><li>Reporter 的接口设计及实现；</li><li>数据上报流程。</li></ol><h3 id=1-1-reporter-的接口设计及实现>1.1、Reporter 的接口设计及实现</h3><p>数据上报是 SofaTracer 基于 OpenTracing Tracer 接口扩展实现出来的功能；Reporter 实例作为 SofaTracer 的属性存在，在构造 SofaTracer 实例时，会初始化 Reporter 实例。</p><h4 id=1-1-1-reporter-接口设计>1.1.1、Reporter 接口设计</h4><p>Reporter 接口是 SOFATracer 中对于数据上报的顶层抽象，核心接口方法定义如下：</p><pre><code class=language-java>//获取 Reporter 实例类型
String getReporterType();
//输出 span
void report(SofaTracerSpan span);
//关闭输出 span 的能力
void close();
</code></pre><p>Reporter 接口的设计中除了核心的上报功能外，还提供了获取 Reporter 类型的能力，这个是因为 SOFATracer 目前提供的埋点机制方案需要依赖这个实现。</p><h4 id=1-1-2-reporter-接口实现>1.1.2、Reporter 接口实现</h4><p>Reporter 的类体系结构如下：</p><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1546936418341-02b4e048-2ffe-4d79-887c-ea0c929f2f00.png alt=image.png></p><p>Reporter 的实现类有两个，SofaTracerCompositeDigestReporterImpl 和  DiskReporterImpl ：</p><ul><li>SofaTracerCompositeDigestReporterImpl：组合摘要日志上报实现，上报时会遍历当前 SofaTracerCompositeDigestReporterImpl 中所有的 Reporter ，逐一执行 report 操作；可供外部用户扩展使用。</li><li>DiskReporterImpl：数据落磁盘的核心实现类，也是目前 SOFATracer 中默认使用的上报器。</li></ul><h3 id=1-2-数据上报流程分析>1.2、数据上报流程分析</h3><p>数据上报实际都是由不同的链路组件发起，关于插件扩展机制及埋点方式不是本篇范畴，就不展开了。这里直接来看数据上报的入口。</p><p>在 Opentracing 规范中提到，Span#finish 方法是 span 生命周期的最后一个执行方法，也就意味着一个 span 跨度即将结束。那么当一个 span 即将结束时，也是当前 span 具有最完整状态的时候。所以在 SOFATracer 中，数据上报的入口就是 Span#finish 方法，这里贴一小段代码：</p><pre><code class=language-java>//SofaTracerSpan#finish
@Override
public void finish(long endTime) {
    this.setEndTime(endTime);
    //关键记录:report span
    this.sofaTracer.reportSpan(this);
    SpanExtensionFactory.logStoppedSpan(this);
}
</code></pre><p>在 finish 方法中，通过 SofaTracer#reportSpan 将当前 span 进行了上报处理。以这个为入口，整个数据上报的调用链路如下图所示：</p><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1547013666391-b59b94f5-3ab1-4058-b515-ff1fc7a45aa7.png alt=image.png></p><p>整个上报调用流程其实并不是很难，这里留两个问题：</p><ul><li>如何构造 clientRportor 和 serverReporter 的，依据是什么？</li><li>摘要日志和统计日志是怎么落盘的？</li></ul><p>第一个问题会在插件埋点解析篇中给出答案；第二个问题下面来看。</p><h2 id=2-日志落盘>2、日志落盘</h2><p>前面已经提到，SOFATracer 本身提供了两种上报模式，一种是落到磁盘，另外一种是上报到zipkin。在实现细节上，SOFATracer 没有将这两种策略分开以提供独立的功能支持，而是将两种上报方式组合在了一起，然后再通过配置参数来控制是否进行具体的上报逻辑，具体参考下图：</p><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1546932866244-20ee0441-fd38-48bb-9891-67d87691bb77.png alt=image.png></p><p>本节将来剖析下日志落盘的实现细节。日志落盘又分为摘要日志落盘 和 统计日志落盘；摘要日志是每一次调用均会落地磁盘的日志；统计日志是每隔一定时间间隔进行统计输出的日志。</p><h3 id=2-1-摘要日志落盘>2.1、摘要日志落盘</h3><p>摘要日志落盘是基于 <a href=https://github.com/LMAX-Exchange/disruptor>Disruptor</a> 高性能无锁循环队列实现的。SOFATracer 中，AsyncCommonDigestAppenderManager 类对 disruptor 进行了封装，用于处理外部组件的 Tracer 摘要日志打印。</p><blockquote><p>关于 Disruptor 的原理及其自身的事件模型此处不展开分析，有兴趣的同学可以自行查阅相关资料。这里直接看下 SOFATracer 中是如何使用 Disruptor 的。</p></blockquote><h4 id=2-1-1-消息事件模型>2.1.1、消息事件模型</h4><p>SOFATracer 使用了两种不同的事件模型，一种是 SOFATracer 内部使用的 StringEvent，一种是外部扩展使用的SofaTacerSpanEvent。详见：<a href=https://github.com/sofastack/sofa-tracer/blob/master/tracer-core/src/main/java/com/alipay/common/tracer/core/appender/manager/SofaTracerSpanEvent.java>SofaTracerSpanEvent</a> &amp; <a href=https://github.com/sofastack/sofa-tracer/blob/master/tracer-core/src/main/java/com/alipay/common/tracer/core/appender/manager/StringEvent.java>StringEvent</a> 。</p><h4 id=2-1-2-consumer-消费者>2.1.2、Consumer 消费者</h4><p>Consumer 是 AsyncCommonDigestAppenderManager 的内部类；实现了 EventHandler 接口，这个 Consumer 作为消费者存在，监听事件，然后通过 TraceAppender 将 span 数据 flush 到磁盘。详见：<a href=https://github.com/sofastack/sofa-tracer/blob/master/tracer-core/src/main/java/com/alipay/common/tracer/core/appender/manager/AsyncCommonDigestAppenderManager.java>AsyncCommonDigestAppenderManager</a></p><h4 id=2-1-3-disruptor-的初始化>2.1.3、Disruptor 的初始化</h4><ul><li>Disruptor 的构建：在 AsyncCommonDigestAppenderManager 的构造函数中完成的。</li></ul><pre><code class=language-java>//构建disruptor，使用的是 ProducerType.MULTI
//等待策略是 BlockingWaitStrategy，考虑到的是CPU的使用率和一致性
disruptor = new Disruptor&lt;SofaTracerSpanEvent&gt;(new SofaTracerSpanEventFactory(),
        realQueueSize, threadFactory, ProducerType.MULTI, new BlockingWaitStrategy());
</code></pre><ul><li>异常处理：如果在消费的过程中发生异常，SOFATracer 将会通过自定义的 ConsumerExceptionHandler 异常处理器把异常信息打到 tracer-self.log 中。</li><li>对于打印相关的参数条件设定，比如是否允许丢弃消息、是否记录丢失日志的数量、是否记录丢失日志的 TraceId 和 RpcId、丢失日志的数量达到某阈值进行一次日志输出等。</li></ul><h4 id=2-1-4-启动-disruptor>2.1.4、启动 Disruptor</h4><p>Disruptor 的启动委托给了 AsyncCommonDigestAppenderManager#start 方法来执行。</p><pre><code class=language-java>public void start(final String workerName) {
    this.threadFactory.setWorkName(workerName);
    this.ringBuffer = this.disruptor.start();
}
</code></pre><p>查看调用栈，看下 SOFATracer 中具体是在哪里调用这个 start 的：</p><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1546945136281-8aa36dbe-e6a3-4799-9760-2608d75613a7.png alt=image.png></p><ul><li>CommonTracerManager : 这里面持有了 AsyncCommonDigestAppenderManager 类的一个单例对象，并且在 static 静态代码块中调用了 start 方法；这个用来输出普通中间件日志。</li><li>SofaTracerDigestReporterAsyncManager：这里类里面也是持有了AsyncCommonDigestAppenderManager 类的一个单例对像，并且提供了getSofaTracerDigestReporterAsyncManager 方法来获取该单例，在这个方法中调用了 start 方法；该对象用来输出摘要日志。</li></ul><h4 id=2-1-5-发布事件>2.1.5、发布事件</h4><p>发布事件，也就意味着当前需要产生一个 span 记录，这个过程也是在 finish 方法的调用栈中，也就是上图中DiskReporterImpl#digestReport 这个方法。</p><pre><code class=language-java>AsyncCommonDigestAppenderManager asyncDigestManager = SofaTracerDigestReporterAsyncManager
            .getSofaTracerDigestReporterAsyncManager();
// ...
asyncDigestManager.append(span);
// ...
</code></pre><p>这里将 span 数据 append 到环形缓冲区，根据 AsyncCommonDigestAppenderManager 的初始化属性，如果允许丢弃，则使用 tryNext 尝试申请序列，申请不到抛出异常；否则使用 next() 阻塞模式申请序列。下面是一个简易的模拟图：</p><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1546941782515-e1aa0f3b-07ac-49f4-a9bd-b0136900c71a.png alt=image.png></p><h4 id=2-1-6-小结>2.1.6、小结</h4><p>摘要日志的落盘依赖于 Disruptor 的事件模型，当 span#finish 方法执行时，触发 SofaTracer 的 report 行为；report 最终会将当前 span 数据放入 Disruptor 队列中去，发布一个 SofaTracerSpanEvent 事件。Disruptor 的消费者 EventHandler 实现类 Consumer 会监听当前队列事件，然后在回调函数 onEvent 中将 span 数据刷新到磁盘中。</p><h3 id=2-2-统计日志落盘实现>2.2、统计日志落盘实现</h3><p>统计日志的作用是为了监控统计使用，其记录了当前跨度的调用次数、执行结果等数据。统计日志是每隔一定时间间隔进行统计输出的日志，因此很容易想到是使用定期任务来执行的。这里同样来跟踪下统计日志打印的方法调用过程。</p><h4 id=2-2-1-统计日志的调用链路>2.2.1、统计日志的调用链路</h4><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1546951038130-269419f8-1bd6-4893-ba54-812a52090237.png alt=image.png></p><p>AbstractSofaTracerStatisticReporter 的 doReportStat 方法是个抽象方法，那这里又是与插件扩展部分联系在一块的：</p><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1546951154851-b3c76870-7a11-4cfa-b5f2-c55027208095.png alt=image.png></p><p>可以看到 AbstractSofaTracerStatisticReporter 的实现类均是在 SOFATracer plugins 包下，也就是说统计日志打印需要由不同的扩展插件来定义实现。但是实际上不同的插件在重写 doReportStat 方法时也并非是直接将 span 数据 flush 到磁盘的，而是将 SofaTracerSpan 转换成 StatMapKey 然后塞到了 AbstractSofaTracerStatisticReporter 中的一个 map 结构对象中。具体细节详见：<a href=https://github.com/sofastack/sofa-tracer/blob/master/tracer-core/src/main/java/com/alipay/common/tracer/core/reporter/stat/AbstractSofaTracerStatisticReporter.java>AbstractSofaTracerStatisticReporter#addStat</a>。</p><h4 id=2-2-2-统计日志的打印模型>2.2.2、统计日志的打印模型</h4><p>前面提到，统计日志的落盘具有一定的周期性，因此在统计日志落盘的设计上，SOFATracer 没有像摘要日志落盘那样依赖于 Disruptor 来实现。下面先通过一张简单的结构图来看下摘要日志的工作模型：</p><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1546954689969-3a8484ab-dfa0-4f0c-9a92-619bcc99b6d0.png alt=image.png></p><ul><li>xxxxxStatReporter : 插件扩展方实现的统计日志 Reporter 类，重写了 doStatReport 和 print 两个方法。</li><li>AbstractSofaTracerStatisticReporter ： 用于扩展的抽象类，xxxxxStatReporter 就是该类的子类；AbstractSofaTracerStatisticReporter 在其构造函数中，通过 SofaTracerStatisticReporterCycleTimesManager 将当前 statReporter 注册到 SofaTracerStatisticReporterManager 中，统一存放在 statReporters 集合中。</li><li>SofaTracerStatisticReporterManager ： 统计日志 reporter 管理器，所有插件扩展的 reporter 都会被注册到这个manager 类里面来。其内部类 StatReporterPrinter 实现了runnable 接口，并在 run 方法中遍历 statReporters，逐一调用 print 方法将数据刷到磁盘中。</li></ul><p>SofaTracerStatisticReporterManager 在构造函数中初始化了任务执行的周期、ScheduledExecutorService 实例初始化，并且将 StatReporterPrinter 提交到定时任务线程池中，从而实现了周期性输出统计日志的功能。</p><h2 id=3-上报-zipkin>3、上报 Zipkin</h2><p>前面对 SOFATracer 中的数据落盘进行了分析，最后再来看下 SOFATracer 中是如何把数据上报至 zipkin 的。</p><h3 id=3-1-上报-zipkin-的流程>3.1、上报 zipkin 的流程</h3><p>接着上面的分析，SOFATracer 中的数据上报策略是以组合的形式共存的，这里可以结合第2节的第一张图来看。这里先给出 zipkin 上报的流程，然后再结合流程展开分析：</p><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1546957272356-3f4c8bdc-59fe-4a43-9012-45d816721a39.png alt=image.png></p><ul><li>在SofaTracer#reportSpan 中有一个方法是 invokeReportListeners；该方法的作用就是遍历当前所有的SpanReportListener 实现类，逐一回调 SpanReportListener 的 onSpanReport 方法。</li><li>ZipkinSofaTracerSpanRemoteReporter 是 sofa-tracer-zipkin-plugin 插件中提供的一个实现了 SpanReportListener 接口的类，并在 onSpanReport 回调函数中通过 zipkin2.reporter.AsyncReporter 实例对象将 span 数据上报至 zipkin。</li><li>虽然 SOFATracer 和 zipkin 均是基于 OpenTracing 规范，但是在具体实现上 SOFATracer 做了很多扩展，因此需要通过一个 ZipkinV2SpanAdapter 将 SofaTracerSpan 适配成 zipkin2.Span。</li></ul><p>zipkin2.reporter.AsyncReporter 是 zipkin 提供的一个数据上报抽象类，默认实现是 BoundedAsyncReporter，其内部通过一个守护线程 flushThread，一直循环调用 BoundedAsyncReporter 的 flush 方法，将内存中的 span 信息上报给 zipkin。</p><h3 id=3-2-对非-springboot-应用的上报支持>3.2、对非 SpringBoot 应用的上报支持</h3><p>上报 zipkin 的能力做过一次改动，主要是对于在非SpringBoot应用(也就是Spring工程)的支持，具体参考 <a href=https://github.com/sofastack/sofa-tracer/issues/32>issue:</a><a href=https://github.com/sofastack/sofa-tracer/issues/32>建议不用spring boot也可以使用sofa-tracer并且上报zipkin</a> 。</p><p>对于 SpringBoot 工程来说，引入 tracer-sofa-boot-starter 之后，自动配置类 SofaTracerAutoConfiguration 会将当前所有 SpanReportListener 类型的 bean 实例保存到 SpanReportListenerHolder 的 List 对象中。而SpanReportListener 类型的 Bean 会在 ZipkinSofaTracerAutoConfiguration 自动配置类中注入到当前 Ioc 容器中。这样 invokeReportListeners 被调用时，就可以拿到 zipkin 的上报类，从而就可以实现上报。</p><p>对于非 SpringBoot 应用的上报支持，本质上是需要实例化 ZipkinSofaTracerSpanRemoteReporter 对象，并将此对象放在 SpanReportListenerHolder 的 List 对象中。所以 SOFATracer 在 zipkin 插件中提供了一个ZipkinReportRegisterBean，并通过实现 Spring 提供的 bean 生命周期接口 InitializingBean，在ZipkinReportRegisterBean 初始化之后构建一个 ZipkinSofaTracerSpanRemoteReporter 实例，并交给SpanReportListenerHolder 类管理。</p><h3 id=3-3-zipkin-上报案例及展示>3.3、Zipkin 上报案例及展示</h3><p>关于 SpringBoot 工程使用 zipkin 上报案例请参考：<a href=https://www.sofastack.tech/sofa-tracer/docs/ReportToZipkin>上报数据到 zipkin</a></p><p>关于 spring 应用中使用 zipkin 上报插件请参考：<a href=https://github.com/glmapper/tracer-zipkin-plugin-demo>tracer-zipkin-plugin-demo</a> </p><ul><li>Services 展示</li></ul><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1547014485100-cd9ddfa9-1163-4f2c-8d2c-55a9101942ae.png alt=image.png></p><ul><li>链路依赖展示</li></ul><p><img src=https://cdn.nlark.com/yuque/0/2019/png/230565/1547014446845-a59153f8-a4fc-4bdf-9aa5-4c70dd174de2.png alt=image.png></p><h2 id=4-总结>4、总结</h2><h3 id=4-1-sofatracer-在数据上报模型上的考虑>4.1、SOFATracer 在数据上报模型上的考虑</h3><p>了解或者使用过 SOFATracer 的同学应该知道， SOFATracer 目前并没有提供数据采集器和 UI 展示的功能；主要有两个方面的考虑：</p><ul><li>SOFATracer 作为 SOFA 体系中一个非常轻量的组件，意在将 span 数据以日志的方式落到磁盘，以便于用户能够更加灵活的来处理这些数据</li><li>UI 展示方面，SOFATracer 本身基于 OpenTracing 规范实现，在模型上与开源的一些产品可以实现无缝对接，在一定程度上可以弥补本身在链路可视化方面的不足。</li></ul><p>因此在上报模型上，SOFATracer 提供了日志输出和外部上报的扩展，方便接入方能够足够灵活的方式来处理上报的数据。</p><h3 id=4-2-文章小结>4.2、文章小结</h3><p>通过本文大家对 SOFATracer 数据上报功能应该有了一个大体的了解，对于内部的实现细节，由于篇幅和文章阅读性等原因，不宜贴过多代码，希望有兴趣的同学可以直接阅读源码，对其中的一些细节进行了解。数据上报作为 SOFATracer 核心扩展能力之一，虽不同的上报途径对应不同的上报模型，但是整体结构上还是比较清晰的，所以理解起来不是很难。</p><p>最后感谢大家对 SOFATracer 的关注，如果您在了解和使用此组件的过程中有任何疑问，欢迎联系我们。</p><h3 id=欢迎加入-参与-sofatracer-源码解析-已领取完毕>欢迎加入，参与 SOFATracer 源码解析【已领取完毕】</h3><p><img src=https://cdn.nlark.com/yuque/0/2019/jpeg/226702/1547173492343-9d987ba1-6fca-420d-9b54-53ad7d77ea0e.jpeg alt=6.jpg></p><p>本文作为《剖析 | <code>SOFATracer</code> 组件系列》第一篇，主要还是希望大家对 <code>SOFATracer</code> 组件有一个认识和了解，之后，我们会逐步详细介绍每部分的代码设计和实现，预计会按照如下的目录进行：</p><ul><li>分布式链路跟踪组件 <code>SOFATracer</code> 概述【已完成】</li><li><code>SOFATracer</code> 数据上报机制和源码分析【已完成】</li><li><code>SOFATracer API </code>组件埋点机制和源码分析【已领取】</li><li><code>SOFATracer </code>链路透传原理与 <code>SLF4J MDC</code> 的扩展能力分析【已领取】</li><li><code>SOFATracer</code> 的采样策略和源码分析【已领取】</li></ul><p>除了源码解析，也欢迎提交 issue 和 PR：</p><p><strong>SOFATracer：</strong><a href=https://github.com/sofastack/sofa-tracer>https://github.com/sofastack/sofa-tracer</a></p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/blog/sofa-tracer-sampling-tracking-deep-dive/><span class=text>上一篇:</span>
<span class=text>蚂蚁金服开源分布式链路跟踪组件 SOFATracer 采样策略和源码剖析</span></a>
<a class=link-next href=/blog/sofa-tracer-overview/><span class=text>下一篇:</span>
<span class=text>蚂蚁金服分布式链路跟踪组件 SOFATracer 总览|剖析</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/blog/sofa-tracer-overview/>蚂蚁金服分布式链路跟踪组件 SOFATracer 总览|剖析</a></li><li><a href=/blog/sofa-tracer-sampling-tracking-deep-dive/>蚂蚁金服开源分布式链路跟踪组件 SOFATracer 采样策略和源码剖析</a></li><li><a href=/blog/sofa-tracer-unvarnished-transmission-slf4j-mdc/>蚂蚁金服开源分布式链路跟踪组件 SOFATracer 链路透传原理与SLF4J MDC 的扩展能力剖析</a></li><li><a href=/blog/sofa-bolt-framework-deep-dive/>蚂蚁金服开源通信框架 SOFABolt 协议框架解析</a></li><li><a href=/blog/sofa-bolt-serialization-deep-dive/>蚂蚁金服开源通信框架SOFABolt解析之序列化机制</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/tags/1024/>1024</a></li><li class=tag><a href=/tags/api-gateway/>API Gateway</a></li><li class=tag><a href=/tags/cafedeployment/>CafeDeployment</a></li><li class=tag><a href=/tags/cloud-native/>Cloud Native</a></li><li class=tag><a href=/tags/cncf/>CNCF</a></li><li class=tag><a href=/tags/db-mesh/>DB Mesh</a></li><li class=tag><a href=/tags/elasticdl/>ElasticDL</a></li><li class=tag><a href=/tags/kata-container/>Kata Container</a></li><li class=tag><a href=/tags/kata-containers/>Kata Containers</a></li><li class=tag><a href=/tags/knative/>Knative</a></li><li class=tag><a href=/tags/kubecon/>KubeCon</a></li><li class=tag><a href=/tags/kubernetes/>Kubernetes</a></li><li class=tag><a href=/tags/meetup/>Meetup</a></li><li class=tag><a href=/tags/mosn/>MOSN</a></li><li class=tag><a href=/tags/occlum/>Occlum</a></li><li class=tag><a href=/tags/seata/>Seata</a></li><li class=tag><a href=/tags/serverless/>Serverless</a></li><li class=tag><a href=/tags/service-mesh/>Service Mesh</a></li><li class=tag><a href=/tags/service-mesh-meetup/>Service Mesh Meetup</a></li><li class=tag><a href=/tags/service-mesh-virtual-meetup/>Service Mesh Virtual Meetup</a></li><li class=tag><a href=/tags/service-mesh-webinar/>Service Mesh Webinar</a></li><li class=tag><a href=/tags/service-mesh-%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/>Service Mesh 落地实践</a></li><li class=tag><a href=/tags/sidecar-%E5%AE%B9%E5%99%A8/>Sidecar 容器</a></li><li class=tag><a href=/tags/sofa-weekly/>SOFA Weekly</a></li><li class=tag><a href=/tags/sofaacts/>SOFAActs</a></li><li class=tag><a href=/tags/sofaark/>SOFAArk</a></li><li class=tag><a href=/tags/sofaarklab/>SOFAArkLab</a></li><li class=tag><a href=/tags/sofabolt/>SOFABolt</a></li><li class=tag><a href=/tags/sofaboot/>SOFABoot</a></li><li class=tag><a href=/tags/sofachannel/>SOFAChannel</a></li><li class=tag><a href=/tags/sofadashboard/>SOFADashboard</a></li><li class=tag><a href=/tags/sofaenclave/>SOFAEnclave</a></li><li class=tag><a href=/tags/sofajraft/>SOFAJRaft</a></li><li class=tag><a href=/tags/sofajraft-%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90/>SOFAJRaft 特性解析</a></li><li class=tag><a href=/tags/sofalab/>SOFALab</a></li><li class=tag><a href=/tags/sofalookout/>SOFALookout</a></li><li class=tag><a href=/tags/sofameetup/>SOFAMeetup</a></li><li class=tag><a href=/tags/sofamesh/>SOFAMesh</a></li><li class=tag><a href=/tags/sofaregistry/>SOFARegistry</a></li><li class=tag><a href=/tags/sofarpc/>SOFARPC</a></li><li class=tag><a href=/tags/sofastack/>SOFAStack</a></li><li class=tag><a href=/tags/sofatracer/>SOFATracer</a></li><li class=tag><a href=/tags/springboot/>SpringBoot</a></li><li class=tag><a href=/tags/sqlflow/>SQLFlow</a></li><li class=tag><a href=/tags/workshop/>Workshop</a></li><li class=tag><a href=/tags/zsearch/>ZSearch</a></li><li class=tag><a href=/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a></li><li class=tag><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a></li><li class=tag><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/>分布式事务</a></li><li class=tag><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/>分布式架构</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofaark-%E6%BA%90%E7%A0%81/>剖析 | SOFAArk 源码</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofabolt-%E6%A1%86%E6%9E%B6/>剖析 | SOFABolt 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofaboot-%E6%A1%86%E6%9E%B6/>剖析 | SOFABoot 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofajraft-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/>剖析 | SOFAJRaft 实现原理</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofaregistry-%E6%A1%86%E6%9E%B6/>剖析 | SOFARegistry 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofarpc-%E6%A1%86%E6%9E%B6/>剖析 | SOFARPC 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofatracer-%E6%A1%86%E6%9E%B6/>剖析 | SOFATracer 框架</a></li><li class=tag><a href=/tags/%E5%AE%9E%E8%B7%B5/>实践</a></li><li class=tag><a href=/tags/%E5%BC%80%E6%BA%90/>开源</a></li><li class=tag><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></li><li class=tag><a href=/tags/%E6%99%BA%E8%83%BD%E7%9B%91%E6%8E%A7/>智能监控</a></li><li class=tag><a href=/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/>智能运维</a></li><li class=tag><a href=/tags/%E6%BA%90%E5%88%9B%E4%BC%9A/>源创会</a></li><li class=tag><a href=/tags/%E9%95%9C%E5%83%8F/>镜像</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/shuaiqiyu>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/community>社区</a>
<a class=link href=/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/projects/soul/overview/>Soul</a>
<a class=link href=/projects/hmily/overview/>Hmily</a>
<a class=link href=/projects/raincat/overview/>Raincat</a>
<a class=link href=/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>