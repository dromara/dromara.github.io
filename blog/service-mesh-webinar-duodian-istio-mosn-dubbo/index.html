<!doctype html><html><head><title>多点生活在 Service Mesh 上的实践 -- Istio &#43; Mosn 在 Dubbo 场景下的探索之路 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-142131411-1','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/><img class=logo src=/img/logo.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/guides/><span>指南</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/>项目</a>
<a class=navbar-item href=/guides/>指南</a>
<a class=navbar-item href=/blog/>博客</a>
<a class=navbar-item href=/activities/>活动</a>
<a class=navbar-item href=/community/>社区</a>
<a class=navbar-item href=/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>多点生活在 Service Mesh 上的实践 -- Istio &#43; Mosn 在 Dubbo 场景下的探索之路</h1><div class=meta>2020-06-04 ·
<a href=https://github.com/sofastack>陈鹏</a> ·
<span class=tags><a class=tag href=/tags/service-mesh/ rel=tag>#Service Mesh</a>
<a class=tag href=/tags/service-mesh-webinar/ rel=tag>#Service Mesh Webinar</a></span></div></div><article class=typo><blockquote><p>Service Mesh Webinar 是由 ServiceMesher 社区和 CNCF 联合发起的线上直播活动，活动将不定期举行，为大家带来 Service Mesh 领域的知识和实践分享。</p></blockquote><p>本文根据5月28日晚 Service Mesh Webinar#1 多点生活平台架构组研发工程师陈鹏，线上主题分享《多点生活在 Service Mesh 上的实践 &ndash; Istio + Mosn 在 Dubbo 场景下的探索之路》整理，文末包含本次分享的视频回顾链接以及 PPT 下载地址。</p><h2 id=前言>前言</h2><p>随着多点生活的业务发展，传统微服务架构的面临升级困难的问题。在云原生的环境下，Service Mesh 能给我们带来什么好处。如何使用社区解决方案兼容现有业务场景，落地成符合自己的 Service Mesh 成为一个难点。</p><p>今天主要给大家分享一下 Service Mesh 的一些技术点以及多点生活在 Service Mesh 落地过程中适配 Dubbo 的一些探索。</p><p>首先我们从三个方面入手：</p><ul><li>为什么需要 Service Mesh 改造；</li><li>探索 Istio 技术点；</li><li>Dubbo 场景下的改造；</li></ul><h2 id=为什么需要-service-mesh-改造>为什么需要 Service Mesh 改造</h2><p>说到为什么需要改造，应该先说一下 Service Mesh 和传统微服务架构的一些特点。</p><h3 id=微服务>微服务</h3><p>微服务一般有这些模块：</p><ul><li>安全；</li><li>配置中心；</li><li>调用链监控；</li><li>网关；</li><li>监控告警；</li><li>注册和发现；</li><li>容错和限流；</li></ul><p>这些模块在传统的微服务架构中有的是和 SDK 结合在一起，有的是一个独立的中间件。</p><p>特点：</p><ul><li>独立部署；</li><li>模块的边界；</li><li>技术多样性；</li></ul><p>正是由于技术多样性，我的微服务系统可以使用不同的语言进行开发，比如我一个商城系统，订单系统使用 Java 开发，库存系统使用 Go 开发，支付系统使用 Python 开发，微服务之间通过轻量级通信机制协作，比如：HTTP/GRPC 等。比如目前多点使用的 Dubbo(服务治理框架)，随着多点生活的业务发展，目前遇到最棘手的问题就是中间件在升级过程中，推进很慢，需要业务方进行配合，接下来我们看看 Service Mesh。</p><h3 id=service-mesh>Service Mesh</h3><p>优点：</p><ul><li>统一的服务治理；</li><li>服务治理和业务逻辑解藕；</li></ul><p>缺点：</p><ul><li>增加运维复杂度；</li><li>引入延时；</li><li>需要更多技术栈；</li></ul><p>看了 Service Mesh 的优缺点，如果我们 Mesh 化了之后就可以解决我们目前的痛点，升级中间件只需要重新发布一下 Sidecar 就好了，不同语言开发的微服务系统可以采用同样的服务治理逻辑，业务方就可以尝试更多的技术。</p><h2 id=探索-istio-技术点>探索 Istio 技术点</h2><p>在谈 Dubbo 场景下的改造之前我们先介绍一下 Istio 相关的技术点，然后结合 Dubbo 场景应该如何进行适配</p><h3 id=mcp>MCP</h3><p>MCP（Mesh Configuration Protocol）提供了一套用于订阅(Watch)、推送(Push)的 API，分为 Source 和 Sink 两个角色。</p><ul><li>Source 是资源提供方(server)，资源变化了之后推送给订阅者(Pilot)，Istio 1.5 之前这个角色就是 Galley 或者自定义 MCP Server；</li><li>Sink 是资源的订阅者(client)，在 Istio 1.5 之前这个角色就是 Pilot 和 Mixer，都是订阅 Galley 或者自定义 MCP Server 的资源</li></ul><p>MCP 的订阅、推送流程图:</p><p><img src=https://cdn.nlark.com/yuque/0/2020/png/226702/1590994674298-e8bbe0ba-a7bb-4034-8214-751eb5b28f43.png alt=mcp></p><p>为了和实际情况结合，我们就以 MCPServer 作为 Source，Pilot 作为 Sink 来介绍订阅、推送流程，其中 MCP 通信过程中所传输的「资源」就是 Istio 定义的 CRD 资源，如：VirtualService、DestinationRules 等。</p><h4 id=订阅>订阅</h4><ul><li>Pilot 启动后会读取 Configmap 的内容，里面有一个 <code>configSources</code> 的一个数组配置（Istio 1.5 之后没有这个配置，需要自己添加）、存放的是 MCP Server 的地址；</li><li>Pilot 连接 MCPServer 之后发送所关注的资源请求；</li><li>MCPServer 收到资源请求，检查请求的版本信息（可能为空），判断版本信息和当前最新维护的版本信息是否一致，不一致则触发 Push 操作，一致则不处理；</li><li>Pilot 收到 Push 数据，处理返回的数据（数据列表可能为空，为空也标示处理成功），根据处理结果返回 ACK（成功）/ NACK（失败），返回的应答中包含返回数据的版本信息，如果返回的是 NACK，Pilot 会继续请求当前资源；</li><li>MCPServer 收到 ACK（和资源请求一致）之后对比版本号，如果一致则不推送，否则继续推送最新数据；</li></ul><h4 id=推送>推送</h4><ul><li>MCPServer 自身数据发生变化，主动推送变化的资源给 Pilot；</li><li>Pilot 收到之后处理这些数据，并根据处理结果返回 ACK / NACK；</li><li>MCPServer 收到 ACK（和资源请求一致） 之后对比版本号，如果一致则不推送，否则继续推送最新数据；</li></ul><p>这样的订阅、推送流程就保证了 MCPServer 和 Pilot 资源的一致。MCPServer 只能通过 MCP 协议告诉 Pilot 资源发生变化了么？当然不是，MCPServer 可以使用创建 CR 的方式，Pilot 通过 Kubernetes 的 Informer 机制也能感知到资源发生变化了，只是通过 MCP 传输的资源在 Kubernetes 里面看不到，只是存在于 Pilot 的内存里面，当然也可以通过 Pilot 提供的 HTTP debug 接口（istiod_ip:8080/debug/configz）来查。</p><p><a href=https://github.com/champly/mcpserver>https://github.com/champly/mcpserver</a>  提供了一个 MCPServer 的一个 demo，如果需要更加细致的了解 MCP 原理可以看一看。</p><blockquote><p><em>更多 debug 接口可以查看: <a href=https://github.com/istio/istio/blob/5b926ddd5f0411aa50fa25c0a6f54178b758cec5/pilot/pkg/proxy/envoy/v2/debug.go#L103>https://github.com/istio/istio/blob/5b926ddd5f0411aa50fa25c0a6f54178b758cec5/pilot/pkg/proxy/envoy/v2/debug.go#L103</a></em></p></blockquote><h3 id=pilot>Pilot</h3><p>Pilot 负责网格中的流量管理以及控制面和数据面之前的配置下发，在 Istio 1.5 之后合并了 Galley、Citadel、Sidecar-Inject 和 Pilot 成为 Istiod。我们这里说的是之前 Pilot 的功能，源码里面 pilot-discovery 的内容。</p><h4 id=功能>功能</h4><ul><li>根据不同平台（Kubernetes、Console）获取一些资源，Kubernetes 中使用 Informer 机制获取 Node、Endpoint、Service、Pod 变化；</li><li>根据用户的配置（CR、MCP 推送、文件）触发推送流程；</li><li>启动 gRPC server 用于接受 Sidecar 的连接；</li></ul><h4 id=推送流程>推送流程</h4><ul><li>记录变化的资源类型；</li><li>根据变化的资源类型(数组)整理本地数据；</li><li>根据变化的资源类型判断需要下发的 xDS 资源；</li><li>构建 xDS 资源，通过 gRPC 下发到连接到当前 Pilot 的 Sidecar；</li></ul><h3 id=xds>xDS</h3><p>Sidecar 通过动态获取服务信息、对服务的发现 API 被称为 xDS。</p><ul><li>协议部分（ADS、控制资源下发的顺序及返回确认的数据）；</li><li>数据部分（CDS、EDS、LDS、RDS、SDS）；</li></ul><p>Pilot 资源类型发生变化需要下发的 xDS 资源对照：</p><table><thead><tr><th align=left>资源名称</th><th align=center>CDS</th><th align=center>EDS</th><th align=center>LDS</th><th align=center>RDS</th></tr></thead><tbody><tr><td align=left>Virtualservices</td><td align=center></td><td align=center></td><td align=center>✔</td><td align=center>✔</td></tr><tr><td align=left>Gateways</td><td align=center></td><td align=center></td><td align=center></td><td align=center></td></tr><tr><td align=left>Serviceentries</td><td align=center>✔</td><td align=center>✔</td><td align=center>✔</td><td align=center>✔</td></tr><tr><td align=left>Destinationrules</td><td align=center>✔</td><td align=center>✔</td><td align=center></td><td align=center>✔</td></tr><tr><td align=left>Envoyfilters</td><td align=center>✔</td><td align=center>✔</td><td align=center>✔</td><td align=center>✔</td></tr><tr><td align=left>Sidecars</td><td align=center>✔</td><td align=center>✔</td><td align=center>✔</td><td align=center>✔</td></tr><tr><td align=left>ConfigClientQuotaspecs</td><td align=center></td><td align=center></td><td align=center>✔</td><td align=center>✔</td></tr><tr><td align=left>ConfigClientQuotaspecbindings</td><td align=center></td><td align=center></td><td align=center>✔</td><td align=center>✔</td></tr><tr><td align=left>Authorizationpolicies</td><td align=center></td><td align=center></td><td align=center>✔</td><td align=center></td></tr><tr><td align=left>Requestauthentications</td><td align=center></td><td align=center></td><td align=center>✔</td><td align=center></td></tr><tr><td align=left>Peerauthentications</td><td align=center>✔</td><td align=center>✔</td><td align=center>✔</td><td align=center></td></tr><tr><td align=left>Other</td><td align=center>✔</td><td align=center>✔</td><td align=center>✔</td><td align=center>✔</td></tr></tbody></table><blockquote><p>_以上内容是根据 <a href=https://github.com/istio/istio/blob/5b926ddd5f0411aa50fa25c0a6f54178b758cec5/pilot/pkg/proxy/envoy/v2/ads_common.go#L97>源码</a> 整理的_</p></blockquote><h3 id=mosn>MOSN</h3><p>MOSN 是一款使用 Go 语言开发的网络代理软件，作为云原生的网络数据平面，旨在为服务提供多协议、模块化、智能化、安全的代理能力。MOSN 是 Modular Open Smart Network 的简称。MOSN 可以与任何支持 xDS API 的 Service Mesh 集成，亦可以作为独立的四、七层负载均衡，API Gateway，云原生 Ingress 等使用。</p><p>MOSN：<a href=https://github.com/mosn/mosn>https://github.com/mosn/mosn</a></p><p>配置文件：</p><ul><li>mosn_config：MOSN 的配置信息；</li><li>listener：LDS；</li><li>routers：RDS；</li><li>cluster：CDS 和 EDS；</li></ul><h4 id=listener>listener</h4><p><img src=https://cdn.nlark.com/yuque/0/2020/png/226702/1590994777393-96eb1de6-4a45-41dd-8470-b98fb244ab2b.png alt=listener></p><p>其中 <code>address</code> 就是 MOSN 监听的地址。</p><h5 id=filter-chains>filter chains</h5><p>filter_chains 在 MOSN 里面的 <code>network chains</code>，实现的还有：</p><ul><li>fault_inject；</li><li>proxy；</li><li>tcp_proxy；</li></ul><p>和 <code>network chains</code> 同级的还有 <code>listener chains</code>、<code>stream chains</code>, 其中
<code>listener chains</code> 目前只有 <code>original_dst</code> 实现。<code>stream chains</code> 可以对请求中的</p><ul><li>StreamSender；</li><li>StreamReceiver；</li><li>StreamAccessLog；</li></ul><p>进行 <code>BeforeRoute</code> <code>AfterRoute</code> 这些关键步骤进行修改请求信息。</p><p>所有的 <code>filter</code> 都只有两种返回结果：</p><ul><li>Continue：如果后面还有 <code>filter</code> 那就执行后续 <code>filter</code>；</li><li>Stop：执行完当前 <code>filter</code> 就不再继续执行了；</li></ul><h5 id=conv>conv</h5><p>看图中的配置信息 <code>config</code> 的内容, <code>downstream_protocol</code> 和 <code>upstream_protocol</code> 这里如果配置不一致，就需要协议转换。比如 <code>HTTP1</code> 转换为 <code>HTTP2</code>，MOSN 就会先把 <code>HTTP1</code> 转换为 <code>common</code> 的中间协议，然后再把 <code>common</code>转换为 <code>HTTP2</code>，这样就实现了协议之间的转换。如果需要自己实现其他协议转换，那么只需要编写转换 <code>common</code> 的内容和 <code>common</code> 转换为当前协议的内容即可实现协议之间的互转。</p><h5 id=proxy>proxy</h5><p>我们再来看 <code>filters</code> 里面的 <code>proxy</code>，这个就是一个会经过路由的代理，配置信息里面配置了<code>router_config_name</code>，就是要路由的<code>router</code>名字。</p><h4 id=routers>routers</h4><p><img src=https://cdn.nlark.com/yuque/0/2020/png/226702/1590994801068-1a27f709-bf26-4798-8c73-e6ea1ced9729.png alt=routers></p><p>根据 <code>listener</code> 里面的 <code>proxy</code> 的配置信息里面的 <code>router_config_name</code> 会找到一个 <code>router</code>，如上图所示。然后就会根据请求里面的 <code>domains</code> 去匹配 <code>virtual_hosts</code>， 这里的 <code>domains</code> 里面在 <code>HTTP</code> 里面就会是 <code>host</code>，当在 Dubbo 协议里面我们可以把 <code>service</code>（有些地方叫做 interface、target，我们这里统一叫 service） 放到 <code>x-mosn-host</code> 这个 MOSN 的 <code>Header</code> 里面，MOSN 就可以根据这个去匹配 <code>domains</code>。</p><p>然后匹配到一个 <code>virtual_hosts</code> 之后，就会得到对应的 <code>routers</code>，这里又会根据 <code>match</code> 里面的匹配规则进行匹配，<code>HTTP</code> 协议里面可以根据 <code>path</code>、<code>queryparam</code>、<code>header</code> 等信息进行匹配，具体匹配规则通过 VirtualService 下发，如果是 Dubbo 协议，那么可以套用 <code>HTTPRoute</code> 规则，然后把 Dubbo 的 <code>attachment</code> 解析出来当作 <code>header</code>去用，目前 MOSN 没有解析 <code>attachment</code>，我们自己实现了一个。</p><p>匹配到了之后会得到一个 <code>route</code>，图中所示只有一个 <code>cluster_name</code>，如果是有多个 <code>subset</code>(DestinationRule 定义)，那么就会有 <code>weighted_cluster</code> ，里面会有 <code>cluster_name</code> 和 <code>weight</code> 构成的对象的数组，例如：</p><pre><code class=language-json>&quot;route&quot;:{
    &quot;weighted_clusters&quot;:[
        {
            &quot;cluster&quot;:{
                &quot;name&quot;:&quot;outbound|20882|green|mosn.io.dubbo.DemoService.workload&quot;,
                &quot;weight&quot;:20
            }
        },
        {
            &quot;cluster&quot;:{
                &quot;name&quot;:&quot;outbound|20882|blue|mosn.io.dubbo.DemoService.workload&quot;,
                &quot;weight&quot;:80
            }
        }
    ],
    &quot;timeout&quot;:&quot;0s&quot;,
    &quot;retry_policy&quot;:{
        &quot;retry_on&quot;:true,
        &quot;retry_timeout&quot;:&quot;3s&quot;,
        &quot;num_retries&quot;:2
    }
}
</code></pre><p>其中 <code>weight</code> 之和必须为 100（Istio 定义的），必须是非负数的整数。</p><p>下面有一些 <code>timeout</code>、<code>retry_policy</code> 服务策略。</p><p>匹配上了之后会得到一个<code>cluster_name</code>，然后我们再看 <code>cluster</code></p><h4 id=cluster>cluster</h4><p>在 <code>routers</code> 里面匹配出来的 <code>cluster_name</code> 作为 <code>key</code> 在 <code>cluster</code> 里面会找到这么一个对象。</p><p><img src=https://cdn.nlark.com/yuque/0/2020/png/226702/1590994825928-2e3e7b50-4841-4cc6-8df6-0123b5d99d16.png alt=cluster></p><p>其中 <code>lb_type</code> 就是节点的负载均衡策略，目前 MOSN 支持：</p><ul><li>ROUNDROBIN；</li><li>RANDOM；</li><li>WEIGHTED_ROUNDROBIN；</li><li>EAST_REQUEST；</li></ul><p><code>hosts</code> 里面的 <code>address</code> 里面也可以配置权重，这个权重必须是大于 0 或小于 129 的整数。可以通过 Istio 1.6 里面的 <code>WorkloadEntry</code> 来配置权重。然后根据负载均衡策略拿到 <code>host</code> 之后直接请求到对应的节点。</p><p>这就完成了流量的转发。接下来我们看看 Dubbo 场景下应该如何改造。</p><h2 id=dubbo-场景下的改造>Dubbo 场景下的改造</h2><p>所有的改造方案里面都是要把 SDK 轻量化，关于服务治理的逻辑下沉到 Sidecar，我们在探索的过程中有三种方案。</p><h3 id=istio-envoy>Istio + Envoy</h3><p>这个方案是 Istio+Envoy 的方案，是参考的华为云的方案: <a href=https://support.huaweicloud.com/bestpractice-istio/istio_bestpractice_3005.html>https://support.huaweicloud.com/bestpractice-istio/istio_bestpractice_3005.html</a></p><ul><li>通过创建 EnvoyFilter 资源来给 xDS 资源打 patch；</li><li>Envoy 解析 Dubbo 协议中的 Service 和 Method；</li><li>根据路由策略配置把流量转发到对应的 Provider；</li></ul><p>这种方案如果需要解析更多的 Dubbo 内容，可以通过 WASM 扩展。</p><h3 id=mosn-dubbo-go>MOSN + Dubbo-go</h3><ul><li>MOSN 提供 Subscribe、Unsubscribe、Publish、Unpublish 的 HTTP 服务；</li><li>SDK 发送请求到 MOSN 提供的这些服务，让 MOSN 代为与真正的注册中心交互；</li><li>MOSN 通过 Dubbo-狗直接和注册中心连接；</li></ul><p>这种方案的话就不需要 Istio。</p><h3 id=istio-mosn>Istio + MOSN</h3><p>这种方案就是我们现在采用的方案，包括：</p><ul><li>数据面改造；</li><li>控制面适配；</li></ul><p>我们有一个理念就是如果能通过标准的 CRD 最好，如果描述不了的话我们就通过 EnvoyFilter 进行修改。这里特别说一下，我们一开始也有一个误区就是 EnvoyFilter 是作用于 Envoy，其实不是的，是对生成好的 xDS 资源进行 ADD, MERGE 等操作，目前只可以修改 LDS、RDS、CDS，这个修改也是有一定局限性的。如果 EnvoyFilter 修改不了某些特定的场景（比如 Istio 1.6 之前的 ServiceEntry 里面的 Endpoint 不能单独为每个实例指定不同的端口），那么我们只能修改 pilot-discovery 的代码，xDS 是不会作任何修改的。按照这个理念，我们开始探索如何改造。</p><h4 id=数据面改造>数据面改造</h4><p><img src=https://cdn.nlark.com/yuque/0/2020/png/226702/1590994844863-2abb501b-3244-4b25-8371-a4237253ffb3.png alt=mosn></p><p>首先有三个端口需要说明一下：</p><ul><li>20880 : provider 监听端口；</li><li>20881 : consumer 请求 mosn 的这个端口，mosn 做转发到 provider；</li><li>20882 : 接受来自下游(mosn/consumer)的请求，直接转到 127.0.0.1:20880；</li></ul><p>步骤：</p><ul><li>provider 启动之后请求本地 mosn 的注册接口，把服务信息注册到注册中心(zk/nacos)，注册请求到达 mosn 之后，mosn 会把注册端口号改为 20882；</li><li>consumer 启动之后不需要连接注册中心，直接把请求发送到 127.0.0.1:20881；</li><li>consumer 端的 mosn 收到请求之后，根据配置信息 listener-&gt;routers-&gt;cluster-&gt;host，找到合适的 host(可以是 provider 的 mosn 或者 直接是 provider) 发送请求，这里的匹配过程可以修改 MOSN 让 Dubbo 的 service 作为 domains，attachment 作为 header；</li><li>provider 端 mosn 收到请求后(20882)，直接转发请求到本地 127.0.0.1:20880；</li></ul><p>这个只是通过静态配置实现的，如果 provider 这些信息如何通过 Pilot 下发呢？</p><h4 id=控制面适配>控制面适配</h4><p>MOSN 本身支持 xDS API，配置信息可以通过 xDS 下发，而不是静态配置。我们有一个对接配置中心，注册中心的程序我们叫 Adapter，这个主要获取注册中心的服务信息，然后根据配置中心的服务治理策略(比如流程比例，还有一些我们内部的一些单元的信息)构建出 Istio 支持的 CR，然后创建 CR，Pilot 自己感知 CR 变化 或者 通过 MCP 把这些信息直接发送给 Pilot，触发 Pilot 的资源变化，然后 Pilot 根据资源的变化去下发一些 xDS 资源，Sidecar 收到资源变化后，就可以动态调整路由策略，从而达到服务治理的目的。</p><p>最终架构图如图所示：</p><p><img src=https://cdn.nlark.com/yuque/0/2020/png/226702/1590994859064-c672218d-b001-4cd5-80fa-65947107d072.png alt=architecture></p><p>注册(灰色部分)：</p><ol><li>provider 发送注册信息给 MOSN；</li><li>MOSN 修改注册信息(端口号等)，然后注册到真正到注册中心(ZK / Nacos 等)；</li></ol><p>配置下发(蓝色部分)：</p><ol><li>Adapter 连接注册中心和配置中心并感知其变化；</li><li>Adapter 感知到变化之后通过 MCP 把变化的信息传递给 Pilot(或者创建 CR 让 Pilot 自己感知)；</li><li>Pilot 感知到资源变化触发配置下发流程，根据变化到资源类型下发对应到 xDS 资源到 连接到它的 Sidecar；</li></ol><p>服务请求(黄色部分)：</p><ol><li>consumer 请求本地 127.0.0.1:20881（MOSN 监听的端口）；</li><li>MOSN 根据 listener-&gt;router-&gt;cluster 找到一个 host，然后把请求转发到这个 host 上；</li></ol><p>以上就完成了服务注册、发现、治理的所有逻辑。</p><p><strong>Istio 1.6 之后可以通过 WorkloadEntry + ServiceEntry 这两种 CRD 资源来描述集群外的服务，当实例上线或者下线的时候就会直接触发 EDS 增量下发</strong>。</p><h2 id=demo-演示>Demo 演示</h2><p>首先要说明一下：</p><ul><li>由于没有真正的注册，所以使用手动添加 ServiceEntry 的方式代替 Adapter 功能；</li><li>Listener 和 Routers 配置信息目前是固定的；</li><li>Provider 只注册到本地 ZK；</li><li>Sidecar 注入到方式使用的是多个 Container；</li></ul><p>具体操作可以按照 <a href=https://github.com/mosn/mosn-tutorial>mosn-tutorial</a>，里面的<code>istio-mosn-adapt-dubbo</code>。即使你没有 Kubernetes 环境也可以尝试的，后期这个会移植到 MOSN 官网，敬请期待。</p><p>mosn-tutorial：<a href=https://github.com/mosn/mosn-tutorial>https://github.com/mosn/mosn-tutorial</a></p><p>以上就是本期分享的全部内容，感谢大家的收看。</p><h2 id=本期嘉宾介绍>本期嘉宾介绍</h2><p>陈鹏，多点生活平台架构组研发工程师，开源项目与云原生爱好者。有多年的网上商城、支付系统相关开发经验，2019年至今从事云原生和 Service Mesh 相关开发工作。</p><h2 id=回顾资料>回顾资料</h2><p>PPT 下载：<a href=https://github.com/servicemesher/meetup-slides/tree/master/2020/05/webinar>https://github.com/servicemesher/meetup-slides/tree/master/2020/05/webinar</a>
视频回顾：<a href=https://www.bilibili.com/video/BV15k4y1r7n8>https://www.bilibili.com/video/BV15k4y1r7n8</a></p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/blog/service-mesh-virtual-meetup1-service-mesh-observability-practice/><span class=text>上一篇:</span>
<span class=text>Service Mesh 中的可观察性实践</span></a>
<a class=link-next href=/blog/sofa-weekly-20200605/><span class=text>下一篇:</span>
<span class=text>SOFA Weekly | MOSN 发版、Service Mesh 相关文章整理、社区直播预告</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/blog/service-mesh-virtual-meetup1-service-mesh-observability-practice/>Service Mesh 中的可观察性实践</a></li><li><a href=/blog/service-mesh-virtual-meetup1-skywalking-observability-applications/>Apache SkyWalking 在 Service Mesh 中的可观察性应用</a></li><li><a href=/blog/service-mesh-virtual-meetup1-practice-in-enterprise-production/>Service Mesh 高可用在企业级生产中的实践 | 线上直播回顾</a></li><li><a href=/activities/service-mesh-webinar-1/>Service Mesh Webinar#1：多点生活在 Service Mesh 上的实践</a></li><li><a href=/blog/mosn-transparent-hijacking/>云原生网络代理 MOSN 透明劫持技术解读 | 开源</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/tags/1024/>1024</a></li><li class=tag><a href=/tags/api-gateway/>API Gateway</a></li><li class=tag><a href=/tags/cafedeployment/>CafeDeployment</a></li><li class=tag><a href=/tags/cloud-native/>Cloud Native</a></li><li class=tag><a href=/tags/cncf/>CNCF</a></li><li class=tag><a href=/tags/db-mesh/>DB Mesh</a></li><li class=tag><a href=/tags/elasticdl/>ElasticDL</a></li><li class=tag><a href=/tags/kata-container/>Kata Container</a></li><li class=tag><a href=/tags/kata-containers/>Kata Containers</a></li><li class=tag><a href=/tags/knative/>Knative</a></li><li class=tag><a href=/tags/kubecon/>KubeCon</a></li><li class=tag><a href=/tags/kubernetes/>Kubernetes</a></li><li class=tag><a href=/tags/meetup/>Meetup</a></li><li class=tag><a href=/tags/mosn/>MOSN</a></li><li class=tag><a href=/tags/occlum/>Occlum</a></li><li class=tag><a href=/tags/seata/>Seata</a></li><li class=tag><a href=/tags/serverless/>Serverless</a></li><li class=tag><a href=/tags/service-mesh/>Service Mesh</a></li><li class=tag><a href=/tags/service-mesh-meetup/>Service Mesh Meetup</a></li><li class=tag><a href=/tags/service-mesh-virtual-meetup/>Service Mesh Virtual Meetup</a></li><li class=tag><a href=/tags/service-mesh-webinar/>Service Mesh Webinar</a></li><li class=tag><a href=/tags/service-mesh-%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/>Service Mesh 落地实践</a></li><li class=tag><a href=/tags/sidecar-%E5%AE%B9%E5%99%A8/>Sidecar 容器</a></li><li class=tag><a href=/tags/sofa-weekly/>SOFA Weekly</a></li><li class=tag><a href=/tags/sofaacts/>SOFAActs</a></li><li class=tag><a href=/tags/sofaark/>SOFAArk</a></li><li class=tag><a href=/tags/sofaarklab/>SOFAArkLab</a></li><li class=tag><a href=/tags/sofabolt/>SOFABolt</a></li><li class=tag><a href=/tags/sofaboot/>SOFABoot</a></li><li class=tag><a href=/tags/sofachannel/>SOFAChannel</a></li><li class=tag><a href=/tags/sofadashboard/>SOFADashboard</a></li><li class=tag><a href=/tags/sofaenclave/>SOFAEnclave</a></li><li class=tag><a href=/tags/sofajraft/>SOFAJRaft</a></li><li class=tag><a href=/tags/sofajraft-%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90/>SOFAJRaft 特性解析</a></li><li class=tag><a href=/tags/sofalab/>SOFALab</a></li><li class=tag><a href=/tags/sofalookout/>SOFALookout</a></li><li class=tag><a href=/tags/sofameetup/>SOFAMeetup</a></li><li class=tag><a href=/tags/sofamesh/>SOFAMesh</a></li><li class=tag><a href=/tags/sofaregistry/>SOFARegistry</a></li><li class=tag><a href=/tags/sofarpc/>SOFARPC</a></li><li class=tag><a href=/tags/sofastack/>SOFAStack</a></li><li class=tag><a href=/tags/sofatracer/>SOFATracer</a></li><li class=tag><a href=/tags/springboot/>SpringBoot</a></li><li class=tag><a href=/tags/sqlflow/>SQLFlow</a></li><li class=tag><a href=/tags/workshop/>Workshop</a></li><li class=tag><a href=/tags/zsearch/>ZSearch</a></li><li class=tag><a href=/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a></li><li class=tag><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a></li><li class=tag><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/>分布式事务</a></li><li class=tag><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/>分布式架构</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofaark-%E6%BA%90%E7%A0%81/>剖析 | SOFAArk 源码</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofabolt-%E6%A1%86%E6%9E%B6/>剖析 | SOFABolt 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofaboot-%E6%A1%86%E6%9E%B6/>剖析 | SOFABoot 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofajraft-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/>剖析 | SOFAJRaft 实现原理</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofaregistry-%E6%A1%86%E6%9E%B6/>剖析 | SOFARegistry 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofarpc-%E6%A1%86%E6%9E%B6/>剖析 | SOFARPC 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofatracer-%E6%A1%86%E6%9E%B6/>剖析 | SOFATracer 框架</a></li><li class=tag><a href=/tags/%E5%AE%9E%E8%B7%B5/>实践</a></li><li class=tag><a href=/tags/%E5%BC%80%E6%BA%90/>开源</a></li><li class=tag><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></li><li class=tag><a href=/tags/%E6%99%BA%E8%83%BD%E7%9B%91%E6%8E%A7/>智能监控</a></li><li class=tag><a href=/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/>智能运维</a></li><li class=tag><a href=/tags/%E6%BA%90%E5%88%9B%E4%BC%9A/>源创会</a></li><li class=tag><a href=/tags/%E9%95%9C%E5%83%8F/>镜像</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/shuaiqiyu>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/community>社区</a>
<a class=link href=/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/projects/soul/overview/>Soul</a>
<a class=link href=/projects/hmily/overview/>Hmily</a>
<a class=link href=/projects/raincat/overview/>Raincat</a>
<a class=link href=/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>