<!doctype html><html><head><title>【剖析 | SOFARPC 框架】之总体设计与扩展机制 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-142131411-1','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/><img class=logo src=/img/logo.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/guides/><span>指南</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/>项目</a>
<a class=navbar-item href=/guides/>指南</a>
<a class=navbar-item href=/blog/>博客</a>
<a class=navbar-item href=/activities/>活动</a>
<a class=navbar-item href=/community/>社区</a>
<a class=navbar-item href=/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>【剖析 | SOFARPC 框架】之总体设计与扩展机制</h1><div class=meta>2018-08-02 ·
<a href=https://github.com/leizhiyuan>碧远</a> ·
<span class=tags><a class=tag href=/tags/sofarpc/ rel=tag>#SOFARPC</a>
<a class=tag href=/tags/%E5%89%96%E6%9E%90-sofarpc-%E6%A1%86%E6%9E%B6/ rel=tag>#剖析 | SOFARPC 框架</a>
<a class=tag href=/tags/sofalab/ rel=tag>#SOFALab</a></span></div></div><article class=typo><h2 id=前言>前言</h2><p>RPC 框架作为分布式技术的基石，在分布式和微服务环境下，扮演着非常重要的角色。</p><p>在蚂蚁金服的分布式技术体系下，我们大量的技术产品（非网关类产品），都需要在内网，进行节点间通信。底层通信框架，已经在蚂蚁自研的 BOLT中的进行了实践，<a href=https://mp.weixin.qq.com/s/JRsbK1Un2av9GKmJ8DK7IQ>BOLT</a> 提供了优秀的通信协议与通信框架，在 BOLT 的基础上，我们研发了自己的 RPC 框架，提供了负载均衡，流量转发，链路追踪，链路数据透传，故障剔除等基础能力，本文将从以下几个方面介绍目前已经开源的 SOFARPC 框架。</p><ol><li>RPC 是什么</li><li>通用 RPC 框架原理</li><li>SOFARPC 框架设计</li></ol><h2 id=rpc是什么>RPC是什么</h2><p>RPC 这个概念术语在上世纪 80 年代由 <a href=https://en.wikipedia.org/wiki/Bruce_Jay_Nelson>Bruce Jay Nelson</a> 提出，在 Nelson 的论文 <a href=http://birrell.org/andrew/papers/ImplementingRPC.pdf>&ldquo;Implementing Remote Procedure Calls&rdquo;</a> 中他提到了几点：</p><ol><li>简单：RPC 概念的语义清晰,简单，方便建立分布式计算。</li><li>高效：在使用方看来,十分简单而且高效。</li><li>通用：通用,适用于各种不同的远程通信调用。</li></ol><p>这里面Nelson提出了一个 RPC框架应该包含的几个部分。</p><ol><li>User</li><li>User-stub</li><li>RPC-Runtime</li><li>Server-stub</li><li>Server</li></ol><p>如下图示，为了和现在我们通用的术语一致，我将 User 改成 Client 了。</p><p><img src=https://cdn.nlark.com/lark/0/2018/png/886/1533126860674-81625d5d-7bf4-4c68-b887-8b2bc0e03577.png alt="典型的 RPC 调用"></p><p>当 Client 想发起一个远程调用时，实际是通过本地调用 Client-stub，而 Client-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPC-Runtime 实例传输到远端的实例。远端 RPC-Runtime 实例收到请求后交给 Server-stub 进行解码后发起本地端调用，在 Java中可以认为就是反射调用,调用结果再返回给 Client 端。</p><p>从上文可以看到，一个典型的 RPC 调用过程还是相对简单的。但是实际上，一个真正的 RPC 框架要做的远不止这些。</p><h2 id=通用-rpc-框架原理>通用 RPC 框架原理</h2><p>相信对 RPC 框架有过一定了解，或者使用过 RPC 产品的同学，在看到了图上之后，会产生几个疑问：</p><p>1.Stub 怎么出现？</p><p>2.怎么打包参数？</p><p>3.怎么传输?</p><p>4.怎么知道目标地址?</p><p>5.怎么发布一个 RPC 服务?</p><p>在解释这些问题之前，这里我画了一张目前通用的 RPC 框架的一个流程图：</p><p><img src=https://cdn.nlark.com/lark/0/2018/png/886/1533126903076-3c13dde4-a8d1-4307-a543-0d5d11cb1602.png alt="通用的 RPC 框架流程图"></p><p>其中：</p><p>1.创建代理解决了 Stub 的问题。</p><p>2.序列化和网络协议编码解决了打包的问题。</p><p>3.服务发现与路由寻址解决了如何知道目标地址的问题。</p><p>4.如何发布一个服务，Registry 来解决。</p><ol><li>Bolt，Netty 等解决了网络传输的问题。</li></ol><p>当然 SOFARPC 的功能不止这些,在解决了这些问题之后，根据业务的需求和实际的线上情况，我们也开发了熔断,限流,故障剔除,数据透传等能力，下面我会来介绍 SOFARPC 的框架设计。</p><h2 id=sofarpc框架设计>SOFARPC框架设计</h2><h3 id=sofarpc-roadmap>SOFARPC RoadMap</h3><p>首先介绍下目前 SOFARPC 的现状和一些正在做的事情。</p><p><img src=https://cdn.nlark.com/lark/0/2018/png/886/1533125859357-61bdcd77-c8cb-4049-b1b9-3c1622ea2249.png alt="SOFARPC RoadMap"></p><p>欢迎对相关功能和 feature 有兴趣的同学，一起参与开发~</p><h3 id=sofarpc-结构设计>SOFARPC 结构设计</h3><p>原理大家清楚之后，为了方便大家尽快上手开发使用，我先从目前的 RPC 框架结构来简单介绍。</p><p><img src=https://cdn.nlark.com/lark/0/2018/png/886/1533125873287-2d6cb058-aa5d-4bb3-819b-9cefc8880153.png alt="SOFARPC 项目结构"></p><p>其中 core和 core-impl 是核心的功能，包含 API 和一些扩展机制，extension-impl 中，则包含了不同的实现和扩展，比如对 http，rest，对 metrics，以及其他注册中心的集成和扩展。</p><p>如 bootstrap 中对协议的支持，remoting 中对网络传输的支持，registry 中对注册中心的支持等。</p><p>在此基础上，由于 RPC 框架涉及服务端和客户端，我会结合 SOFARPC 的处理流程，详细介绍下客户端和服务端的处理。</p><h3 id=客户端调用流程>客户端调用流程</h3><p><img src=https://cdn.nlark.com/lark/0/2018/png/886/1533123875347-74b6a14e-0c0d-410a-bb89-e9c7e3046802.png alt="SOFARPC 客户端调用流程"></p><p>当使用方对服务进行了引用配置之后：</p><p>1.RPC 生成 Proxy，作为用户可以操作的入口。</p><p>2.向服务中心订阅这个 RPC 的地址信息。</p><p>3.使用方发起调用，经过路由，负载均衡，各类 Filter 发起调用。</p><h3 id=服务端处理流程>服务端处理流程</h3><p><img src=https://cdn.nlark.com/lark/0/2018/png/886/1533123881349-42414252-711d-4448-8f97-346ab23dc06b.png alt="SOFARPC 服务端处理流程"></p><p>在服务端看来,通过 TCP 监听端口后：</p><p>1.接到 RPC 请求后，进行解码和反序列化。</p><p>2.选择线程池，进行分发。</p><p>3.经过 Filter，进行反射调用。</p><p>4.将结果序列化，编码,进行写回。</p><h3 id=可扩展的机制>可扩展的机制</h3><p>从上面的流程中，可以看到，每个部分基本都有多种实现可选，这得益于RPC的扩展机制。</p><p>为了对 RPC 各个环节的都有充足的可扩展性，提供 SPI 的能力，所以内部的实现和第三方实现都是<strong>绝对平等</strong>的。</p><p>相比原生 SPI，我们实现了更强大的功能</p><ol><li><p>按需加载</p></li><li><p>可以有别名</p></li><li><p>可以有优先级进行排序和覆盖</p></li><li><p>可以控制是否单例</p></li><li><p>可以在某些场景下使用编码</p></li><li><p>可以指定扩展配置位置</p></li><li><p>可以排斥其他扩展点</p></li></ol><p>我们实现了一套自己的 SPI 机制。整个流程如下：</p><p><img src=https://tva1.sinaimg.cn/large/006y8mN6ly1g8n8jj6lnaj30rz0l8dgm.jpg alt="SPI 机制"></p><p>在启动加载阶段，RPC 会根据对应的配置，加载需要调用方法<code>ExtensionLoader(Class&lt;T&gt; interfaceClass, ExtensionLoaderListener&lt;T&gt; listener)</code>
逻辑如下：</p><ol><li><p>首先读取<code>rpc-config-default.json</code>和<code>rpc-config.json</code>，找到扩展描述文件存放的文件夹：<code>extension.load.path</code>属性。</p></li><li><p>找到接口类对应的扩展描述文件的文件名（默认就是接口名，也可以自己指定）。</p></li><li><p>循环加载这个文件下的扩展描述文件，按行读取。（同一个接口的同一个别名对应唯一的一个实现类，可以重复，允许覆盖。）</p></li><li><p>保存扩展实现类的alias和实现类的对应关系。</p></li><li><p>如果 ExtensionLoaderListener 不为空，则通知 Listener。</p></li></ol><p>最终，将会构造出各个不同的 Filter，Invoker 等等。</p><p>其中我们首先设计了一个扩展，代表这个类或者接口是可扩展的，默认单例、不需要编码。</p><pre><code class=language-java>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface Extensible {

    /**
     * 指定自定义扩展文件名称，默认就是全类名
     *
     * @return 自定义扩展文件名称
     */
    String file() default &quot;&quot;;

    /**
     * 扩展类是否使用单例，默认使用
     *
     * @return 是否使用单例
     */
    boolean singleton() default true;

    /**
     * 扩展类是否需要编码，默认不需要
     *
     * @return 是否需要编码
     */
    boolean coded() default false;
}
</code></pre><p>同时，针对具体的扩展实现，定义一个扩展注解</p><pre><code class=language-java>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface Extension {
    /**
     * 扩展点名字
     *
     * @return 扩展点名字
     */
    String value();

    /**
     * 扩展点编码，默认不需要，当接口需要编码的时候需要
     *
     * @return 扩展点编码
     * @see Extensible#coded()
     */
    byte code() default -1;

    /**
     * 优先级排序，默认不需要，大的优先级高
     *
     * @return 排序
     */
    int order() default 0;

    /**
     * 是否覆盖其它低{@link #order()}的同名扩展
     *
     * @return 是否覆盖其它低排序的同名扩展
     * @since 5.2.0
     */
    boolean override() default false;

    /**
     * 排斥其它扩展，可以排斥掉其它低{@link #order()}的扩展
     *
     * @return 排斥其它扩展
     * @since 5.2.0
     */
    String[] rejection() default {};
}
</code></pre><p>通过核心类 ExtensionLoader 的加载过程。完成对扩展的加载：</p><p><img src=https://cdn.nlark.com/lark/0/2018/png/886/1533123901334-640ed6a1-5f0f-47aa-9b34-cc4036830e6a.png alt=扩展点加载主流程></p><p>当我们或者其他使用者想要实现一个自己的扩展点的时候，只需要按照如下的步骤即可开始。</p><ol><li>指定<strong>扩展点</strong></li></ol><pre><code class=language-java>@Extensible(singleton = false)
public abstract class Client {
}
</code></pre><ol><li>指定<strong>扩展实现类</strong></li></ol><pre><code class=language-java>@Extension(&quot;failover&quot;)
public class FailoverClient extends AbstractClient {
}
</code></pre><ol><li><strong>扩展描述文件</strong> <code>META-INF/services/sofa-rpc/com.aliapy.sofa.rpc.client.Client</code></li></ol><pre><code class=language-properties>failover=com.aliapy.sofa.rpc.client.FailoverClient
</code></pre><p>当这些准备完成后，直接调用即可。</p><pre><code class=language-java>Client failoverClient = ExtensionLoaderFactory.getExtensionLoader(Client.class).getExtension(&quot;failover&quot;);
</code></pre><p>基于这套扩展加载机制，我们可以实现自定义扩展点，实现 SOFARPC 内部及第三方的自由扩展。</p><h2 id=总结>总结</h2><p>本文作为 SOFARPC 框架第一篇，主要还是希望大家对 RPC 框架有一个认识和了解，之后，我们会逐步详细介绍每部分的代码设计和实现，预计会按照如下的目录进行：</p><ol><li><p>SOFARPC 同步异步实现剖析</p></li><li><p>SOFARPC 线程模型剖析</p></li><li><p>SOFARPC 连接管理与心跳剖析</p></li><li><p>SOFARPC 单机故障剔除剖析</p></li><li><p>SOFARPC 路由实现剖析</p></li><li><p>SOFARPC 序列化比较</p></li><li><p>SOFARPC 注解支持剖析</p></li><li><p>SOFARPC 优雅关闭剖析</p></li><li><p>SOFARPC 链路追踪剖析</p></li><li><p>SOFARPC 数据透传剖析</p></li><li><p>SOFARPC 跨语言支持剖析</p></li><li><p>SOFARPC 泛化调用实现剖析</p></li></ol><p>以上有对某个主题特别感兴趣的同学，可以留言讨论，我们会适当根据大家的反馈调整文章的顺序，也请大家继续支持 SOFA ，支持 <a href=https://github.com/sofastack/sofa-rpc>SOFARPC</a> 。</p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/blog/sofastack-modular-isolation/><span class=text>上一篇:</span>
<span class=text>蚂蚁金服的业务系统模块化之模块化隔离方案</span></a>
<a class=link-next href=/blog/sofa-rpc-link-tracking/><span class=text>下一篇:</span>
<span class=text>【剖析 | SOFARPC 框架】之 SOFARPC 链路追踪剖析</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/blog/sofa-rpc-zookeeper-integriation/>SOFARPC 集成 Zookeeper 注册中心</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/tags/1024/>1024</a></li><li class=tag><a href=/tags/api-gateway/>API Gateway</a></li><li class=tag><a href=/tags/cafedeployment/>CAFEDeployment</a></li><li class=tag><a href=/tags/cloud-native/>Cloud Native</a></li><li class=tag><a href=/tags/cncf/>CNCF</a></li><li class=tag><a href=/tags/db-mesh/>DB Mesh</a></li><li class=tag><a href=/tags/elasticdl/>ElasticDL</a></li><li class=tag><a href=/tags/kata-container/>Kata Container</a></li><li class=tag><a href=/tags/kata-containers/>Kata Containers</a></li><li class=tag><a href=/tags/knative/>Knative</a></li><li class=tag><a href=/tags/kubecon/>KubeCon</a></li><li class=tag><a href=/tags/kubernetes/>Kubernetes</a></li><li class=tag><a href=/tags/meetup/>Meetup</a></li><li class=tag><a href=/tags/mosn/>MOSN</a></li><li class=tag><a href=/tags/occlum/>Occlum</a></li><li class=tag><a href=/tags/seata/>Seata</a></li><li class=tag><a href=/tags/serverless/>Serverless</a></li><li class=tag><a href=/tags/service-mesh/>Service Mesh</a></li><li class=tag><a href=/tags/service-mesh-meetup/>Service Mesh Meetup</a></li><li class=tag><a href=/tags/service-mesh-virtual-meetup/>Service Mesh Virtual Meetup</a></li><li class=tag><a href=/tags/service-mesh-webinar/>Service Mesh Webinar</a></li><li class=tag><a href=/tags/service-mesh-%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/>Service Mesh 落地实践</a></li><li class=tag><a href=/tags/sidecar-%E5%AE%B9%E5%99%A8/>Sidecar 容器</a></li><li class=tag><a href=/tags/sofa-weekly/>SOFA Weekly</a></li><li class=tag><a href=/tags/sofaacts/>SOFAActs</a></li><li class=tag><a href=/tags/sofaark/>SOFAArk</a></li><li class=tag><a href=/tags/sofaarklab/>SOFAArkLab</a></li><li class=tag><a href=/tags/sofabolt/>SOFABolt</a></li><li class=tag><a href=/tags/sofaboot/>SOFABoot</a></li><li class=tag><a href=/tags/sofachannel/>SOFAChannel</a></li><li class=tag><a href=/tags/sofadashboard/>SOFADashboard</a></li><li class=tag><a href=/tags/sofaenclave/>SOFAEnclave</a></li><li class=tag><a href=/tags/sofajraft/>SOFAJRaft</a></li><li class=tag><a href=/tags/sofajraft-%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90/>SOFAJRaft 特性解析</a></li><li class=tag><a href=/tags/sofalab/>SOFALab</a></li><li class=tag><a href=/tags/sofalookout/>SOFALookout</a></li><li class=tag><a href=/tags/sofameetup/>SOFAMeetup</a></li><li class=tag><a href=/tags/sofamesh/>SOFAMesh</a></li><li class=tag><a href=/tags/sofaregistry/>SOFARegistry</a></li><li class=tag><a href=/tags/sofarpc/>SOFARPC</a></li><li class=tag><a href=/tags/sofastack/>SOFAStack</a></li><li class=tag><a href=/tags/sofatracer/>SOFATracer</a></li><li class=tag><a href=/tags/springboot/>SpringBoot</a></li><li class=tag><a href=/tags/sqlflow/>SQLFlow</a></li><li class=tag><a href=/tags/workshop/>Workshop</a></li><li class=tag><a href=/tags/zsearch/>ZSearch</a></li><li class=tag><a href=/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a></li><li class=tag><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a></li><li class=tag><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/>分布式事务</a></li><li class=tag><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/>分布式架构</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofaark-%E6%BA%90%E7%A0%81/>剖析 | SOFAArk 源码</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofabolt-%E6%A1%86%E6%9E%B6/>剖析 | SOFABolt 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofaboot-%E6%A1%86%E6%9E%B6/>剖析 | SOFABoot 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofajraft-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/>剖析 | SOFAJRaft 实现原理</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofaregistry-%E6%A1%86%E6%9E%B6/>剖析 | SOFARegistry 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofarpc-%E6%A1%86%E6%9E%B6/>剖析 | SOFARPC 框架</a></li><li class=tag><a href=/tags/%E5%89%96%E6%9E%90-sofatracer-%E6%A1%86%E6%9E%B6/>剖析 | SOFATracer 框架</a></li><li class=tag><a href=/tags/%E5%AE%9E%E8%B7%B5/>实践</a></li><li class=tag><a href=/tags/%E5%BC%80%E6%BA%90/>开源</a></li><li class=tag><a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/>微服务</a></li><li class=tag><a href=/tags/%E6%99%BA%E8%83%BD%E7%9B%91%E6%8E%A7/>智能监控</a></li><li class=tag><a href=/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/>智能运维</a></li><li class=tag><a href=/tags/%E6%BA%90%E5%88%9B%E4%BC%9A/>源创会</a></li><li class=tag><a href=/tags/%E9%95%9C%E5%83%8F/>镜像</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/shuaiqiyu>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/community>社区</a>
<a class=link href=/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/projects/soul/overview/>Soul</a>
<a class=link href=/projects/hmily/overview/>Hmily</a>
<a class=link href=/projects/raincat/overview/>Raincat</a>
<a class=link href=/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>