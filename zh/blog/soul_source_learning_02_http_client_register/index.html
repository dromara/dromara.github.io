<!doctype html><html><head><title>Soul网关学习(2-3)Http客户端接入源码解析 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?a02cb5c75097762223d5a815a03e0a15";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/zh/><img class=logo src=/img/logo/dromara.jpg></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/soul_source_learning_02_http_client_register/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/>项目</a>
<a class=navbar-item href=/zh/blog/>博客</a>
<a class=navbar-item href=/zh/activities/>活动</a>
<a class=navbar-item href=/zh/community/>社区</a>
<a class=navbar-item href=/zh/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/blog/soul_source_learning_02_http_client_register/>En</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Soul网关学习(2-3)Http客户端接入源码解析</h1><div class=meta>2021-01-18 ·
范金鹏 ·
<span class=tags><a class=tag href=/zh/tags/soul/ rel=tag>#Soul</a></span></div></div><article class=typo><h1 id=http-用户接入-soul-网关注册逻辑分析>HTTP 用户接入 Soul 网关注册逻辑分析</h1><h2 id=1-注册入口>1. 注册入口</h2><p>HTTP 用户接入 Soul 网关时，会调用 soul-admin 一个接口，把需要 Soul 网关管理的接口注册，今天就具体看看到底干了点儿啥。</p><p>先看下调用的接口信息如下：</p><pre><code class=language-java>// SpringMvcClientBeanPostProcessor.java
/**
 * Instantiates a new Soul client bean post processor.
 *
 * @param soulSpringMvcConfig the soul spring mvc config
 */
public SpringMvcClientBeanPostProcessor(final SoulSpringMvcConfig soulSpringMvcConfig) {
    ValidateUtils.validate(soulSpringMvcConfig);
    this.soulSpringMvcConfig = soulSpringMvcConfig;
    url = soulSpringMvcConfig.getAdminUrl() + &quot;/soul-client/springmvc-register&quot;;
    executorService = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;());
}
</code></pre><h2 id=2-springmvc-register-接口逻辑>2. springmvc-register 接口逻辑</h2><p>全局搜索 &ldquo;springmvc-register&rdquo;，找到 soul-admin 模块下的 SoulClientController，看到这里，对于经常写 CRUD 的我们是不是很熟悉？哈哈~</p><pre><code class=language-java>// SoulClientController.java
/**
 * Register spring mvc string.
 *
 * @param springMvcRegisterDTO the spring mvc register dto
 * @return the string
 */
@PostMapping(&quot;/springmvc-register&quot;)
public String registerSpringMvc(@RequestBody final SpringMvcRegisterDTO springMvcRegisterDTO) {
    return soulClientRegisterService.registerSpringMvc(springMvcRegisterDTO);
}
</code></pre><p>Service 层实现类：</p><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
@Override
@Transactional
public String registerSpringMvc(final SpringMvcRegisterDTO dto) {
    if (dto.isRegisterMetaData()) {
        MetaDataDO exist = metaDataMapper.findByPath(dto.getPath());
        if (Objects.isNull(exist)) {
            saveSpringMvcMetaData(dto);
        }
    }
    String selectorId = handlerSpringMvcSelector(dto);
    handlerSpringMvcRule(selectorId, dto);
    return SoulResultMessage.SUCCESS;
}
</code></pre><p>dto.isRegisterMetaData() 这个是否注册元数据信息的判断，不知道什么时候用，存疑 //TODO，先往下走。</p><h3 id=2-1-先看看这个方法-handlerspringmvcselector-处理-selector>2.1 先看看这个方法 handlerSpringMvcSelector，处理 Selector。</h3><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private String handlerSpringMvcSelector(final SpringMvcRegisterDTO dto) {
    String contextPath = dto.getContext();
    // 根据 contextPath 到数据库里查询，是否已经注册过。
    SelectorDO selectorDO = selectorService.findByName(contextPath);
    String selectorId;
    String uri = String.join(&quot;:&quot;, dto.getHost(), String.valueOf(dto.getPort()));
    if (Objects.isNull(selectorDO)) {
        // 还没有注册过
        selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri);
    } else {
        // 已经注册过，业务系统重启了会到这里
        selectorId = selectorDO.getId();
        //update upstream
        String handle = selectorDO.getHandle();
        String handleAdd;
        DivideUpstream addDivideUpstream = buildDivideUpstream(uri);
        SelectorData selectorData = selectorService.buildByName(contextPath);
        if (StringUtils.isBlank(handle)) {
            handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream));
        } else {
            List&lt;DivideUpstream&gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream.class);
            for (DivideUpstream upstream : exist) {
                if (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) {
                    return selectorId;
                }
            }
            exist.add(addDivideUpstream);
            handleAdd = GsonUtils.getInstance().toJson(exist);
        }
        selectorDO.setHandle(handleAdd);
        selectorData.setHandle(handleAdd);
        // update db
        selectorMapper.updateSelective(selectorDO);
        // submit upstreamCheck
        upstreamCheckService.submit(contextPath, addDivideUpstream);
        // publish change event.
        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,
                Collections.singletonList(selectorData)));
    }
    return selectorId;
}
</code></pre><h4 id=2-1-1-第一次接入-soul-网关>2.1.1 第一次接入 Soul 网关</h4><p>新接入的，到数据库里肯定查不到 selectorDO，进入 registerSelector 方法，仔细看看到底往哪些数据库表中插数据了。</p><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private String registerSelector(final String contextPath, final String rpcType, final String appName, final String uri) {
    SelectorDTO selectorDTO = SelectorDTO.builder()
            .name(contextPath)
            .type(SelectorTypeEnum.CUSTOM_FLOW.getCode())
            .matchMode(MatchModeEnum.AND.getCode())
            .enabled(Boolean.TRUE)
            .loged(Boolean.TRUE)
            .continued(Boolean.TRUE)
            .sort(1)
            .build();
    if (RpcTypeEnum.DUBBO.getName().equals(rpcType)) {
        selectorDTO.setPluginId(getPluginId(PluginEnum.DUBBO.getName()));
    } else if (RpcTypeEnum.SPRING_CLOUD.getName().equals(rpcType)) {
        selectorDTO.setPluginId(getPluginId(PluginEnum.SPRING_CLOUD.getName()));
        selectorDTO.setHandle(GsonUtils.getInstance().toJson(buildSpringCloudSelectorHandle(appName)));
    } else if (RpcTypeEnum.SOFA.getName().equals(rpcType)) {
        selectorDTO.setPluginId(getPluginId(PluginEnum.SOFA.getName()));
        selectorDTO.setHandle(appName);
    } else if (RpcTypeEnum.TARS.getName().equals(rpcType)) {
        selectorDTO.setPluginId(getPluginId(PluginEnum.TARS.getName()));
        selectorDTO.setHandle(appName);
    } else {
        //is divide
        DivideUpstream divideUpstream = buildDivideUpstream(uri);
        String handler = GsonUtils.getInstance().toJson(Collections.singletonList(divideUpstream));
        selectorDTO.setHandle(handler);
        selectorDTO.setPluginId(getPluginId(PluginEnum.DIVIDE.getName()));
        upstreamCheckService.submit(selectorDTO.getName(), divideUpstream);
    }
    SelectorConditionDTO selectorConditionDTO = new SelectorConditionDTO();
    selectorConditionDTO.setParamType(ParamTypeEnum.URI.getName());
    selectorConditionDTO.setParamName(&quot;/&quot;);
    selectorConditionDTO.setOperator(OperatorEnum.MATCH.getAlias());
    selectorConditionDTO.setParamValue(contextPath + &quot;/**&quot;);
    selectorDTO.setSelectorConditions(Collections.singletonList(selectorConditionDTO));
    return selectorService.register(selectorDTO);
}
</code></pre><p>看到这么多 if else，是不是很兴奋，小伙伴们可以想想怎么优化掉这么多 if else，PR 搞起来 ^ - ^。</p><p>写了这么多，无非是封装 SelectorDTO 对象，最后调用 selectorService.register(selectorDTO) 入库，继续跟进去。</p><pre><code class=language-java>// SelectorServiceImpl.java
@Override
public String register(final SelectorDTO selectorDTO) {
    SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);
    List&lt;SelectorConditionDTO&gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();
    if (StringUtils.isEmpty(selectorDTO.getId())) {
        selectorMapper.insertSelective(selectorDO);
        selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {
            selectorConditionDTO.setSelectorId(selectorDO.getId());
            // 这里在 for 循环里调用 dao 层插入数据，是不是可以考虑挪出去一次性批量插入？
            selectorConditionMapper.insertSelective(SelectorConditionDO
                    .buildSelectorConditionDO(selectorConditionDTO));
        });
    }
    publishEvent(selectorDO, selectorConditionDTOs);
    return selectorDO.getId();
}
</code></pre><p>看到这里有2条入库方法，分别向 selector 和 selector_condition 表中插入了数据。这里我们先不具体追究表结构及业务意义，后面补上。</p><p>publishEvent 方法，涉及到 ApplicationEventPublisher 接口，是观察者模式的一个实现，发布事件后通过监听器完成后续操作，这里先按下不表，后续单写一篇文章分析。</p><h4 id=2-1-2-已经接入-soul-网关>2.1.2 已经接入 Soul 网关</h4><p>就跟盗梦空间似的，我们回退2层梦境，回到插入数据的另一个分支，可以想见，就是，已经接入过 Soul 网关的系统重启，或新节点启动走的逻辑。</p><p>把前面的代码再贴过来：</p><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private String handlerSpringMvcSelector(final SpringMvcRegisterDTO dto) {
    String contextPath = dto.getContext();
    // 根据 contextPath 到数据库里查询，是否已经注册过。
    SelectorDO selectorDO = selectorService.findByName(contextPath);
    String selectorId;
    String uri = String.join(&quot;:&quot;, dto.getHost(), String.valueOf(dto.getPort()));
    if (Objects.isNull(selectorDO)) {
        // 还没有注册过
        selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri);
    } else {
        // 已接入的业务系统重启，或新节点启动，会到这里
        selectorId = selectorDO.getId();
        //update upstream
        // handle 字段存储这个接口真实节点信息，可能存在多台机器需要负载均衡的场景
        String handle = selectorDO.getHandle();
        String handleAdd;
        DivideUpstream addDivideUpstream = buildDivideUpstream(uri);
        SelectorData selectorData = selectorService.buildByName(contextPath);
        if (StringUtils.isBlank(handle)) {
            // 这个接口虽然之前注册过，但第1个服务器节点接入 Soul 时会进来
            handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream));
        } else {
            // 如果已经至少有1个服务器节点已接入，会进到这里，判断是否是同一个节点（使用 upstreamUrl 区分），如果相同直接返回
            List&lt;DivideUpstream&gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream.class);
            for (DivideUpstream upstream : exist) {
                if (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) {
                    return selectorId;
                }
            }
            // 如果不是同一个节点，把新节点加入到 handle 字段中
            exist.add(addDivideUpstream);
            handleAdd = GsonUtils.getInstance().toJson(exist);
        }
        selectorDO.setHandle(handleAdd);
        selectorData.setHandle(handleAdd);
        // update db 更新数据库
        selectorMapper.updateSelective(selectorDO);
        // submit upstreamCheck
        upstreamCheckService.submit(contextPath, addDivideUpstream);
        // publish change event.
        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,
                Collections.singletonList(selectorData)));
    }
    return selectorId;
}
</code></pre><p>因为还没有研究数据库表结构设计，根据已知部分猜测，1个 selector 对应一个 divide 插件，这个插件以 contextPath 为标识（在这里就是 &ldquo;/http&rdquo;），一个 contextPath 可以部署多个服务器节点，这些节点信息已 json 形式保存在 handle 字段中。</p><pre><code class=language-json>// handle/handleAdd 数据格式
[
    {
        &quot;upstreamHost&quot;: &quot;localhost&quot;,
        &quot;protocol&quot;: &quot;http://&quot;,
        &quot;upstreamUrl&quot;: &quot;10.0.0.12:8188&quot;,
        &quot;weight&quot;: 50,
        &quot;status&quot;: true,
        &quot;timestamp&quot;: 0,
        &quot;warmup&quot;: 0
    }
]
</code></pre><p>下面紧接着就是更新数据库 updateSelective。</p><p>upstreamCheckService.submit(contextPath, addDivideUpstream); 把真实服务器节点信息缓存在一个 Map(UPSTREAM_MAP) 里，有定时任务定期探活，如果发现服务节点宕机了，就把他剔除出去，防止把请求发送到已经宕机的节点上。</p><p>然后就是 eventPublisher.publishEvent()，跟前面的 publishEvent 方法一样，发布事件后通过监听器完成后续操作（简单介绍下，这里是通过与 Soul 网关建立的 websocket 长连接发送数据 SelectorData 修改的消息，Soul 网关根据消息修改数据，这个具体改的什么数据，怎么修改的，后面分析）。</p><p>到这里终于把 handlerSpringMvcSelector 这个方法分析完了。</p><h3 id=2-2-再来看看这个方法-handlerspringmvcrule-处理-rule>2.2 再来看看这个方法 handlerSpringMvcRule，处理 Rule。</h3><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private void handlerSpringMvcRule(final String selectorId, final SpringMvcRegisterDTO dto) {
    RuleDO ruleDO = ruleMapper.findByName(dto.getRuleName());
    if (Objects.isNull(ruleDO)) {
        registerRule(selectorId, dto.getPath(), dto.getRpcType(), dto.getRuleName());
    }
}
</code></pre><p>首先拿着规则名字，到 rule 表里捞数据，如果捞到了表名已经注册过了，无操作。</p><p>看下数据库数据，就是业务系统下的接口地址。</p><pre><code class=language-bash>mysql&gt; use soul;
Database changed

mysql&gt; select * from rule where name = '/http/order/findById' \G
*************************** 1. row ***************************
          id: 1349650371868782592
 selector_id: 1349650371302551552
  match_mode: 0
        name: /http/order/findById
     enabled: 1
       loged: 1
        sort: 1
      handle: {&quot;loadBalance&quot;:&quot;random&quot;,&quot;retry&quot;:0,&quot;timeout&quot;:3000}
date_created: 2021-01-14 17:31:39
date_updated: 2021-01-14 17:31:39
1 row in set (0.00 sec)
</code></pre><p>如果没捞到数据，注册这个规则。</p><pre><code class=language-java>// SoulClientRegisterServiceImpl.java
private void registerRule(final String selectorId, final String path, final String rpcType, final String ruleName) {
    RuleHandle ruleHandle = RuleHandleFactory.ruleHandle(RpcTypeEnum.acquireByName(rpcType), path);
    RuleDTO ruleDTO = RuleDTO.builder()
            .selectorId(selectorId)
            .name(ruleName)
            .matchMode(MatchModeEnum.AND.getCode())
            .enabled(Boolean.TRUE)
            .loged(Boolean.TRUE)
            .sort(1)
            .handle(ruleHandle.toJson())
            .build();
    RuleConditionDTO ruleConditionDTO = RuleConditionDTO.builder()
            .paramType(ParamTypeEnum.URI.getName())
            .paramName(&quot;/&quot;)
            .paramValue(path)
            .build();
    if (path.indexOf(&quot;*&quot;) &gt; 1) {
        ruleConditionDTO.setOperator(OperatorEnum.MATCH.getAlias());
    } else {
        ruleConditionDTO.setOperator(OperatorEnum.EQ.getAlias());
    }
    ruleDTO.setRuleConditions(Collections.singletonList(ruleConditionDTO));
    ruleService.register(ruleDTO);
}
</code></pre><p>第1行，根据 rpcType(&ldquo;http&rdquo;) 获取其对应的 RuleHandle，这里，默认内置3种类型，我们这里的是 HTTP，对应 DivideRuleHandle。</p><pre><code class=language-java>// RuleHandleFactory.java
public final class RuleHandleFactory {

    /**
     * The RpcType to RuleHandle class map.
     */
    private static final Map&lt;RpcTypeEnum, Class&lt;? extends RuleHandle&gt;&gt; RPC_TYPE_TO_RULE_HANDLE_CLASS = new ConcurrentHashMap&lt;&gt;();

    /**
     * The default RuleHandle.
     */
    private static final Class&lt;? extends RuleHandle&gt; DEFAULT_RULE_HANDLE = SpringCloudRuleHandle.class;

    static {
        RPC_TYPE_TO_RULE_HANDLE_CLASS.put(RpcTypeEnum.HTTP, DivideRuleHandle.class);
        RPC_TYPE_TO_RULE_HANDLE_CLASS.put(RpcTypeEnum.DUBBO, DubboRuleHandle.class);
        RPC_TYPE_TO_RULE_HANDLE_CLASS.put(RpcTypeEnum.SOFA, SofaRuleHandle.class);
    }

    /**
     * Get a RuleHandle object with given rpc type and path.
     * @param rpcType   rpc type.
     * @param path      path.
     * @return          RuleHandle object.
     */
    public static RuleHandle ruleHandle(final RpcTypeEnum rpcType, final String path) {
        if (Objects.isNull(rpcType)) {
            return null;
        }
        Class&lt;? extends RuleHandle&gt; clazz = RPC_TYPE_TO_RULE_HANDLE_CLASS.getOrDefault(rpcType, DEFAULT_RULE_HANDLE);
        try {
            return clazz.newInstance().createDefault(path);
        } catch (InstantiationException | IllegalAccessException e) {
            throw new SoulException(
                    String.format(&quot;Init RuleHandle failed with rpc type: %s, rule class: %s, exception: %s&quot;,
                            rpcType,
                            clazz.getSimpleName(),
                            e.getMessage()));
        }
    }
}
</code></pre><p>下面构造 RuleDTO 对象，注册规则。</p><pre><code class=language-java>// RuleServiceImpl.java
@Override
public String register(final RuleDTO ruleDTO) {
    RuleDO ruleDO = RuleDO.buildRuleDO(ruleDTO);
    List&lt;RuleConditionDTO&gt; ruleConditions = ruleDTO.getRuleConditions();
    if (StringUtils.isEmpty(ruleDTO.getId())) {
        ruleMapper.insertSelective(ruleDO);
        ruleConditions.forEach(ruleConditionDTO -&gt; {
            ruleConditionDTO.setRuleId(ruleDO.getId());
            // 这里在 for 循环里调用 dao 层插入数据，是不是可以考虑挪出去一次性批量插入？
            ruleConditionMapper.insertSelective(RuleConditionDO
                    .buildRuleConditionDO(ruleConditionDTO));
        });
    }
    publishEvent(ruleDO, ruleConditions);
    return ruleDO.getId();
}
</code></pre><p>分别向 rule 和 rule_condition 表中插入数据。</p><p>publishEvent() 方法，通过 websocket 长连接，向 Soul 网关发送 RuleData 数据。</p><h2 id=3-总结>3.总结</h2><p>到这里，调用 &ldquo;/soul-client/springmvc-register&rdquo; 接口逻辑分析完了，我们总结下：</p><ul><li>处理 selector<ul><li>新增或修改 selector、selector_condition 表数据，持久化到 MySQL。</li><li>通过 websocket 向 Soul 网关发送数据改动信息。</li></ul></li><li>处理 rule<ul><li>新增或修改 rule、rule_condition 表数据，持久化到 MySQL。</li><li>通过 websocket 向 Soul 网关发送数据改动信息。</li></ul></li></ul><p>其中表结构及字段含义还需进一步学习和研究，websocket 发送给 Soul 网关后，网关做了什么处理也需要后续分析。</p><p>到这里，HTTP 用户接入 Soul 网关注册逻辑就分析完了。</p><p>如果在工作中你有使用网关的需求，或是个人有学习网关的追求，欢迎来跟我一起分析和学习，Soul 网关，你值得拥有。</p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/zh/blog/soul_source_learning_02_divide_plugin_source/><span class=text>上一篇:</span>
<span class=text>Soul网关学习(2-2)Http代理之divide插件源码解析</span></a>
<a class=link-next href=/zh/blog/soul_source_learning_13_zookeeper_01/><span class=text>下一篇:</span>
<span class=text>Soul网关学习Zookeeper数据同步01</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/zh/blog/soul_source_learning_02_divide_plugin_source/>Soul网关学习(2-2)Http代理之divide插件源码解析</a></li><li><a href=/zh/blog/soul_source_learning_02_divide_plugin/>Soul网关学习(2-1)Http代理之divide插件使用</a></li><li><a href=/zh/blog/soul_source_learning_01/>Soul网关学习(1)环境配置</a></li><li><a href=/zh/blog/soul_source_learning_05_plugin/>Soul网关学习插件链与负载均衡解析</a></li><li><a href=/zh/community/soul-2.2.0/>【Soul网关发布2.2.0】让高性能网关变得如此简单！</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/dromara/>Dromara</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/hmily/>hmily</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/soul/>Soul</a></li><li class=tag><a href=/zh/tags/tcc/>TCC</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/dromara>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/zh/community>社区</a>
<a class=link href=/zh/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=https://shenyu.apache.org/zh/projects/shenyu/overview/>Apache ShenYu</a>
<a class=link href=/zh/projects/hmily/overview/>Hmily</a>
<a class=link href=/zh/projects/raincat/overview/>Raincat</a>
<a class=link href=/zh/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>@dromara. org. All Rights Reserved</a></p></div></footer></body></html>