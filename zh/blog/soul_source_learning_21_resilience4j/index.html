<!doctype html><html><head><title>Soul网关学习Resilience4j插件原理解析 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?a02cb5c75097762223d5a815a03e0a15";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/zh/><img class=logo src=/img/logo/dromara.jpg></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/soul_source_learning_21_resilience4j/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/>项目</a>
<a class=navbar-item href=/zh/blog/>博客</a>
<a class=navbar-item href=/zh/activities/>活动</a>
<a class=navbar-item href=/zh/community/>社区</a>
<a class=navbar-item href=/zh/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/blog/soul_source_learning_21_resilience4j/>En</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Soul网关学习Resilience4j插件原理解析</h1><div class=meta>2021-03-22 ·
闫兵 ·
<span class=tags><a class=tag href=/zh/tags/soul/ rel=tag>#Soul</a></span></div></div><article class=typo><h2 id=目标>目标</h2><ul><li>什么是Resilience4J</li><li>soul的Resilience4j体验<ul><li>限流</li><li>熔断</li></ul></li><li>Resilience4J插件源码解读</li></ul><h2 id=什么是resilience4j>什么是Resilience4j</h2><ul><li>Resilience4J是Spring Cloud Gateway推荐的容错方案，它是一个轻量级的容错库</li><li>借鉴了Hystrix而设计，并且采用JDK8 这个函数式编程，即lambda表达式</li><li>相比之下， Netflix Hystrix 对Archaius 具有编译依赖性，Resilience4j你无需引用全部依赖，可以根据自己需要的功能引用相关的模块即可
Hystrix不更新了，Spring提供Netflix Hystrix的替换方案，即Resilence4J</li><li><p>Resilience4J 提供了一系列增强微服务的可用性功能：</p><ul><li>断路器 CircuitBreaker</li><li>限流 RateLimiter</li><li>基于信号量的隔离</li><li>缓存</li><li>限时 Timelimiter</li><li>请求重启 Retry</li></ul></li><li><p>官方提供的依赖包</p><pre><code class=language-Java> &lt;dependency&gt;
        &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;
        &lt;artifactId&gt;resilience4j-circuitbreaker&lt;/artifactId&gt;
        &lt;version&gt;${resilience.version}&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre><h2 id=soul的resilience4j体验>soul的Resilience4j体验</h2><ul><li><p>首先在soul-admin控制台插件管理开启Resilience4j
<img src="https://img-blog.csdnimg.cn/20210321112151395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY5MjQz,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p></li><li><p>在soul网关添加依赖</p><pre><code class=language-Java>&lt;dependency&gt;
    &lt;groupId&gt;org.dromara&lt;/groupId&gt;
    &lt;artifactId&gt;soul-spring-boot-starter-plugin-ratelimiter&lt;/artifactId&gt;
    &lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></li></ul></li><li><p>启动三个服务,分别是一个soul-admin，一个soul-bootstrap，一个soul-examples-http</p></li><li><p>在soul-admin控制台找到插件列表的Resilience4j，自定义配置，如下图，
<img src="https://img-blog.csdnimg.cn/20210321112202189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODY5MjQz,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p></li><li><p><a href=https://dromara.org/zh/projects/soul/resilience4j-plugin/>soul官网的配置介绍</a></p><pre><code>* Resilience4j处理详解：

    * timeoutDurationRate：等待获取令牌的超时时间，单位ms，默认值：5000。

    * limitRefreshPeriod：刷新令牌的时间间隔，单位ms，默认值：500。

    * limitForPeriod：每次刷新令牌的数量，默认值：50。

    * circuitEnable：是否开启熔断，0：关闭，1：开启，默认值：0。

    * timeoutDuration：熔断超时时间，单位ms，默认值：30000。

    * fallbackUri：降级处理的uri。

    * slidingWindowSize：滑动窗口大小，默认值：100。

    * slidingWindowType：滑动窗口类型，0：基于计数，1：基于时间，默认值：0。

    * minimumNumberOfCalls：开启熔断的最小请求数，超过这个请求数才开启熔断统计，默认值：100。

    * waitIntervalFunctionInOpenState：熔断器开启持续时间，单位ms，默认值：10。

    * permittedNumberOfCallsInHalfOpenState：半开状态下的环形缓冲区大小，必须达到此数量才会计算失败率，默认值：10。

    * failureRateThreshold：错误率百分比，达到这个阈值，熔断器才会开启，默认值50。

    * automaticTransitionFromOpenToHalfOpenEnabled：是否自动从open状态转换为half-open状态，,true：是，false：否，默认值：false。
</code></pre></li></ul><h3 id=限流>限流</h3><ul><li>参数配置
如下是参数配置校验，参数值小于默认值，会直接赋值默认值，因此方便测试效果直接修改源码的配置
： 每次刷新令牌的数量为2 ，刷新令牌的时间间隔为1s，超时时间为1s</li></ul><pre><code class=language-java>    /**
     * check filed default value.
     *
     * @param resilience4JHandle {@linkplain Resilience4JHandle}
     * @return {@linkplain Resilience4JHandle}
     */
    public Resilience4JHandle checkData(final Resilience4JHandle resilience4JHandle) {
        resilience4JHandle.setTimeoutDurationRate(Math.max(resilience4JHandle.getTimeoutDurationRate(), Constants.TIMEOUT_DURATION_RATE));
           //resilience4JHandle.setLimitRefreshPeriod(Math.max(resilience4JHandle.getLimitRefreshPeriod(), Constants.LIMIT_REFRESH_PERIOD));
           //resilience4JHandle.setLimitForPeriod(Math.max(resilience4JHandle.getLimitForPeriod(), Constants.LIMIT_FOR_PERIOD));
        //每次刷新令牌的数量为2 ，刷新令牌的时间间隔为1s
        resilience4JHandle.setLimitRefreshPeriod(1000);
        resilience4JHandle.setLimitForPeriod(2);
        resilience4JHandle.setTimeoutDuration(1000);
        resilience4JHandle.setCircuitEnable(Math.max(resilience4JHandle.getCircuitEnable(), Constants.CIRCUIT_ENABLE));
           //resilience4JHandle.setTimeoutDuration(Math.max(resilience4JHandle.getTimeoutDuration(), Constants.TIMEOUT_DURATION));
        resilience4JHandle.setFallbackUri(!&quot;0&quot;.equals(resilience4JHandle.getFallbackUri()) ? resilience4JHandle.getFallbackUri() : &quot;&quot;);
        resilience4JHandle.setSlidingWindowSize(Math.max(resilience4JHandle.getSlidingWindowSize(), Constants.SLIDING_WINDOW_SIZE));
        resilience4JHandle.setSlidingWindowType(Math.max(resilience4JHandle.getSlidingWindowType(), Constants.SLIDING_WINDOW_TYPE));
        resilience4JHandle.setMinimumNumberOfCalls(Math.max(resilience4JHandle.getMinimumNumberOfCalls(), Constants.MINIMUM_NUMBER_OF_CALLS));
        resilience4JHandle.setWaitIntervalFunctionInOpenState(Math.max(resilience4JHandle.getWaitIntervalFunctionInOpenState(), Constants.WAIT_INTERVAL_FUNCTION_IN_OPEN_STATE));
        resilience4JHandle.setPermittedNumberOfCallsInHalfOpenState(Math.max(resilience4JHandle.getPermittedNumberOfCallsInHalfOpenState(), Constants.PERMITTED_NUMBER_OF_CALLS_IN_HALF_OPEN_STATE));
        resilience4JHandle.setFailureRateThreshold(Math.max(resilience4JHandle.getFailureRateThreshold(), Constants.FAILURE_RATE_THRESHOLD));
        return resilience4JHandle;
    }
</code></pre><ul><li>使用SuperBenchmarker工具，4个线程，执行10s</li></ul><pre><code class=language-java>C:\Users\v-yanb07&gt;sb -u http://localhost:9195/http/test/findByUserId?userId=1 -c 4 -N 10
Starting at 2021-03-14 15:46:28
[Press C to stop the test]
23      (RPS: 1)
---------------Finished!----------------
Finished at 2021-03-14 15:46:51 (took 00:00:23.0477097)
24      (RPS: 1)                        Status 200:    25

RPS: 2.2 (requests/second)
Max: 2020ms
Min: 472ms
Avg: 1677ms

  50%   below 1994ms
  60%   below 1997ms
  70%   below 1999ms
  80%   below 1999ms
  90%   below 2001ms
  95%   below 2019ms
  98%   below 2020ms
  99%   below 2020ms
99.9%   below 2020ms
</code></pre><ul><li><p>输出日志</p><pre><code class=language-java>2021-03-14 12:16:35.252  INFO 379336 --- [ctor-http-nio-7] o.d.s.e.h.controller.HttpTestController  : 限流测试
2021-03-14 12:16:36.249  INFO 379336 --- [ctor-http-nio-4] o.d.s.e.h.controller.HttpTestController  : 限流测试
2021-03-14 12:16:36.250  INFO 379336 --- [ctor-http-nio-7] o.d.s.e.h.controller.HttpTestController  : 限流测试
2021-03-14 12:16:37.250  INFO 379336 --- [ctor-http-nio-7] o.d.s.e.h.controller.HttpTestController  : 限流测试
2021-03-14 12:16:37.250  INFO 379336 --- [ctor-http-nio-4] o.d.s.e.h.controller.HttpTestController  : 限流测试
2021-03-14 12:16:38.250  INFO 379336 --- [ctor-http-nio-7] o.d.s.e.h.controller.HttpTestController  : 限流测试
2021-03-14 12:16:38.250  INFO 379336 --- [ctor-http-nio-4] o.d.s.e.h.controller.HttpTestController  : 限流测试
2021-03-14 12:16:39.252  INFO 379336 --- [ctor-http-nio-7] o.d.s.e.h.controller.HttpTestController  : 限流测试
2021-03-14 12:16:39.252  INFO 379336 --- [ctor-http-nio-4] o.d.s.e.h.controller.HttpTestController  : 限流测试
</code></pre><p>控制台日志每秒输出两条，由此验证限流生效</p><h3 id=熔断>熔断</h3><ul><li>从配置信息我们知道熔断器默认是关闭，我们需要开打</li><li><p>soul-examples-http调用接口处添加休眠时间</p><pre><code class=language-java>@GetMapping(&quot;/findByUserId&quot;)
public UserDTO findByUserId(@RequestParam(&quot;userId&quot;) final String userId) throws Exception{
UserDTO userDTO = new UserDTO();
userDTO.setUserId(userId);
userDTO.setUserName(&quot;hello world&quot;);
log.info(&quot;限流测试&quot;);

int i = RandomUtils.nextInt(1,3);
if(i %2==0){
        //throw new Exception(&quot;异常抛出&quot;);
Thread.currentThread().sleep(2000);
}
return userDTO;
}
</code></pre></li></ul></li><li><p>Resilience4JHandle#checkData手动设置超时时间为1s</p><pre><code class=language-java>resilience4JHandle.setTimeoutDuration(1000);
</code></pre><ul><li>pos接口调用
&gt;<a href="http://localhost:9195/http/test/findByUserId?userId=1">http://localhost:9195/http/test/findByUserId?userId=1</a></li></ul><p>多次请求时，有的请求返回正常数据，有的请求返回如下数据，表示超时熔断生效</p><pre><code class=language-java>{
&quot;code&quot;: 500,
&quot;message&quot;: &quot;Internal Server Error&quot;,
&quot;data&quot;: &quot;404 NOT_FOUND&quot;
}
</code></pre></li></ul><h2 id=resilience4j插件源码解读>Resilience4J插件源码解读</h2><p>soul网关Resilience4j插件源码大量使用了<a href=https://developer.ibm.com/zh/languages/java/articles/j-cn-with-reactor-response-encode/>响应式编程</a>方式，首先需要对响应式编程了解</p><ul><li><p>Resilience4J插件目录结构</p><pre><code>└─resilience4j
│  Resilience4JPlugin.java                   //插件处理，核心类
│  
├─build
│      Resilience4JBuilder.java              //构建Resilience4JConf对象
│      
├─conf
│      Resilience4JConf.java
│      
├─executor
│      CombinedExecutor.java                 //限流和熔断执行器
│      Executor.java
│      RateLimiterExecutor.java              //限流执行器
│      
├─factory
│      Resilience4JRegistryFactory.java      //限流和熔断对象构建
│      
└─handler
        Resilience4JHandler.java
</code></pre></li><li><p>Resilience4JPlugn#doExecute
Resilience4JPlugn其他soul中插件一样继承AbstractSoulPlugin，只要开启了，通过链式机制执行，都会走到核心方法doExecute</p><pre><code class=language-java>@Override
protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {
    final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);
    assert soulContext != null;
    //获取配置信息对象
    Resilience4JHandle resilience4JHandle = GsonUtils.getGson().fromJson(rule.getHandle(), Resilience4JHandle.class);
    //校验配置信息，如果小于默认值，则赋值默认值
    resilience4JHandle = resilience4JHandle.checkData(resilience4JHandle);
    //circuitEnable配置：1 开启熔断组件 ，否则走限流组件
    if (resilience4JHandle.getCircuitEnable() == 1) {
        return combined(exchange, chain, rule);
    }

    return rateLimiter(exchange, chain, rule);
}
</code></pre><ul><li>限流 Resilience4JPlugin#rateLimiter</li></ul><pre><code class=language-java>private Mono&lt;Void&gt; rateLimiter(final ServerWebExchange exchange, final SoulPluginChain chain, final RuleData rule) {
return ratelimiterExecutor.run(
        // chain.execute(exchange)  后续插件执行
        chain.execute(exchange), fallback(ratelimiterExecutor, exchange, null), Resilience4JBuilder.build(rule))
        .onErrorResume(throwable -&gt; ratelimiterExecutor.withoutFallback(exchange, throwable))  
    

//ratelimiterExecutor.run调用
@Override
public &lt;T&gt; Mono&lt;T&gt; run(final Mono&lt;T&gt; toRun, final Function&lt;Throwable, Mono&lt;T&gt;&gt; fallback, final Resilience4JConf conf) {
//限流器组件
RateLimiter rateLimiter = Resilience4JRegistryFactory.rateLimiter(conf.getId(), conf.getRateLimiterConfig());
//限流执行
Mono&lt;T&gt; to = toRun.transformDeferred(RateLimiterOperator.of(rateLimiter));
if (fallback != null) {
//回调的执行
    return to.onErrorResume(fallback);
}
return to;
}


// to.onErrorResume(fallback);
default Mono&lt;Void&gt; fallback(ServerWebExchange exchange, String uri, Throwable t) {
if (StringUtils.isBlank(uri)) {
    return withoutFallback(exchange, t);
}
DispatcherHandler dispatcherHandler = SpringBeanUtils.getInstance().getBean(DispatcherHandler.class);
ServerHttpRequest request = exchange.getRequest().mutate().uri(Objects.requireNonNull(UriUtils.createUri(uri))).build();
ServerWebExchange mutated = exchange.mutate().request(request).build();
//回调的执行地方
return dispatcherHandler.handle(mutated);
}    
</code></pre></li><li><p>熔断 Resilience4JPlugin#combined</p></li></ul><pre><code class=language-java>    private Mono&lt;Void&gt; combined(final ServerWebExchange exchange, final SoulPluginChain chain, final RuleData rule) {
        Resilience4JConf conf = Resilience4JBuilder.build(rule);
        return combinedExecutor.run(
                chain.execute(exchange).doOnSuccess(v -&gt; {
                    HttpStatus status = exchange.getResponse().getStatusCode();
                    if (status == null || !status.is2xxSuccessful()) {
                        exchange.getResponse().setStatusCode(null);
                        throw new CircuitBreakerStatusCodeException(status == null ? HttpStatus.INTERNAL_SERVER_ERROR : status);
                    }
                }), fallback(combinedExecutor, exchange, conf.getFallBackUri()), conf);
    }


   //combinedExecutor#run执行的内容
    public &lt;T&gt; Mono&lt;T&gt; run(final Mono&lt;T&gt; run, final Function&lt;Throwable, Mono&lt;T&gt;&gt; fallback, final Resilience4JConf resilience4JConf) {
        RateLimiter rateLimiter = Resilience4JRegistryFactory.rateLimiter(resilience4JConf.getId(), resilience4JConf.getRateLimiterConfig());
        CircuitBreaker circuitBreaker = Resilience4JRegistryFactory.circuitBreaker(resilience4JConf.getId(), resilience4JConf.getCircuitBreakerConfig());
                     //断路器的操作
        Mono&lt;T&gt; to = run.transformDeferred(CircuitBreakerOperator.of(circuitBreaker))
                //限流操作
                .transformDeferred(RateLimiterOperator.of(rateLimiter))
                //设置超时时间
                .timeout(resilience4JConf.getTimeLimiterConfig().getTimeoutDuration())
                //如果超时了抛出超时异常
                .doOnError(TimeoutException.class, t -&gt; circuitBreaker.onError(
                        resilience4JConf.getTimeLimiterConfig().getTimeoutDuration().toMillis(),
                        TimeUnit.MILLISECONDS,
                        t));
        if (fallback != null) {
            to = to.onErrorResume(fallback);
        }
        return to;
    }
</code></pre><h2 id=总结>总结</h2><ul><li>soul网关提供限流和熔断，熔断默认是关闭的</li><li>参数值小于默认值，会直接使用默认值</li></ul></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/zh/blog/soul_source_learning_20_sentinel/><span class=text>上一篇:</span>
<span class=text>Soul网关学习Sentinel插件原理解析</span></a>
<a class=link-next href=/zh/blog/soul_source_learning_22_apache_dubbo/><span class=text>下一篇:</span>
<span class=text>Soul网关学习Apache Dubbo插件原理解析</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/zh/blog/soul_source_learning_20_sentinel/>Soul网关学习Sentinel插件原理解析</a></li><li><a href=/zh/blog/soul_source_learning_19_redirect/>Soul网关学习Redirect插件原理解析</a></li><li><a href=/zh/activities/dromara-cloud-native-meet-02/>Dromara Soul 源码01期阅读分享会02</a></li><li><a href=/zh/blog/soul_source_learning_16_divide_sxj/>Soul网关学习divide插件源码解读</a></li><li><a href=/zh/blog/soul_source_learning_18_ratelimiter/>Soul网关学习RateLimiter插件原理解析</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/dromara/>Dromara</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/hmily/>hmily</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/soul/>Soul</a></li><li class=tag><a href=/zh/tags/tcc/>TCC</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/dromara>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/zh/community>社区</a>
<a class=link href=/zh/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=https://shenyu.apache.org/zh/projects/shenyu/overview/>Apache ShenYu</a>
<a class=link href=/zh/projects/hmily/overview/>Hmily</a>
<a class=link href=/zh/projects/raincat/overview/>Raincat</a>
<a class=link href=/zh/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>@dromara. org. All Rights Reserved</a></p></div></footer></body></html>