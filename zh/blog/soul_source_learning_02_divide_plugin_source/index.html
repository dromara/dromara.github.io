<!doctype html><html><head><title>Soul网关学习(2-2)Http代理之divide插件源码解析 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/zh/><img class=logo src=/img/logo.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/guides/><span>指南</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/>项目</a>
<a class=navbar-item href=/zh/guides/>指南</a>
<a class=navbar-item href=/zh/blog/>博客</a>
<a class=navbar-item href=/zh/activities/>活动</a>
<a class=navbar-item href=/zh/community/>社区</a>
<a class=navbar-item href=/zh/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Soul网关学习(2-2)Http代理之divide插件源码解析</h1><div class=meta>2021-01-17 ·
季鹏 ·
<span class=tags><a class=tag href=/zh/tags/soul/ rel=tag>#Soul</a></span></div></div><article class=typo><h1 id=divide-插件如何转发http请求>Divide 插件如何转发http请求</h1><p>先来设想一下，网关如果收到了一个请求<a href="http://xxx.com/openapi/appname/order/findById?id=3，那么怎么将请求转发给对应的业务？">http://xxx.com/openapi/appname/order/findById?id=3，那么怎么将请求转发给对应的业务？</a></p><p>可以想象一下大概是这几个步骤：</p><ul><li>1.解析url</li><li>2.查看配置文件，看这个url是对应于哪个业务线</li><li>3.读配置文件，获取该业务线在网关注册的所有api列表</li><li>4.判断该用户的这个api请求在不在业务的api列表里面</li><li>5.进行相关的鉴权操作（用户AK/SK鉴权、用户Quota/QPS有没有超）</li><li>6.如果网关有负载均衡功能，那么需要获取业务具体给API配置的负载均衡策略</li><li>7.网关向具体的业务API发起请求</li><li>8.网关将收到的业务API的response发送给用户</li></ul><p>这篇笔记主要来学习一下suol网关是怎么转发http请求的。</p><p>先看一下官方文档的相关介绍<a href=https://dromara.org/zh-cn/docs/soul/user-http.html>http用户</a>、<a href=https://dromara.org/zh-cn/docs/soul/plugin-divide.html>Divide插件</a></p><p>官方文档里面介绍到，如果网关需要支持http转发，那么需要在网关的pom里面有以下依赖：</p><pre><code>        &lt;!--if you use http proxy start this--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.dromara&lt;/groupId&gt;
            &lt;artifactId&gt;soul-spring-boot-starter-plugin-divide&lt;/artifactId&gt;
            &lt;version&gt;${project.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.dromara&lt;/groupId&gt;
            &lt;artifactId&gt;soul-spring-boot-starter-plugin-httpclient&lt;/artifactId&gt;
            &lt;version&gt;${project.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--if you use http proxy end this--&gt;
</code></pre><p>那么可以知道http请求的代理与<code>plugin-divide</code>,<code>plugin-httpclient</code>这两个插件有关。</p><h2 id=插件链>插件链</h2><p>官方文档中说到<code>divide</code>这个插件是实现http请求代理的核心，下面看一下<code>soul-plugin/soul-plugin-divide</code>这个模块的代码，可以看到有一个<code>DividePlugin</code>类，继承自<code>AbstractPlugin</code>，而<code>AbstractPlugin</code>实现了<code>SoulPlugin</code>接口</p><p><img src="https://img-blog.csdnimg.cn/2021011523120836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center" alt=DividePlugin的继承关系></p><p>可以看到<code>SoulPlugin</code>是<code>DividePlugin</code>的父类，那么猜测一下<code>SoulPlugin</code>是所有插件的父类。全局搜索一下<code>SoulPlugin</code>果然如此，它是诸多插件的父类。</p><p>在全局搜索<code>SoulPlugin</code>的时候，发现<code>soul-web/src/main/java/org/dromara/soul/web/handler</code>里有一个类<code>SoulWebHandler</code>里面有一个属性是<code>List&lt;SoulPlugin&gt;</code>，猜测<code>SoulWebHandler</code>可以操作多个插件。</p><p><img src="https://img-blog.csdnimg.cn/20210115230954422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center" alt=SoulWebHandler里面有List&lt;SoulPlugin&gt;></p><p>看一下<code>SoulWebHandler</code>的继承关系图，发现它是继承了<code>WebHandler</code>，而<code>WebHandler</code>是spring框架里面的一个接口。</p><p><img src="https://img-blog.csdnimg.cn/2021011523103754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center" alt=SoulWebHandler的继承关系图>
由于对WebFlux不了解，上网快速搜索了一下WebHandler，得知这是WebFlux里面一个很重要的东西，它提供了一套通用的http请求处理方案。</p><p>而soul网关的源码里面，自己实现了一个实现了<code>WebHandler</code>接口的<code>SoulWebHandler</code>类，无疑是希望框架使用soul实现的这套东西来处理请求。</p><p>在<code>soul-web/src/main/java/org/dromara/soul/web/configuration</code>里的<code>SoulConfiguration</code>类，它在类头上声明了注解<code>@Configuration</code>，表明它是一个配置。<code>SoulConfiguration</code>类里面向spring容器注入了一个名为<code>webHandler</code>的bean，该bean是SoulWebHandler类型的。Application会在启动的时候扫描被<code>@Configuration</code>注解的类，所以通过以下代码，<code>SoulWebHandler</code>就被注入到spring容器中去了。</p><pre><code>    @Bean(&quot;webHandler&quot;)
    public SoulWebHandler soulWebHandler(final ObjectProvider&lt;List&lt;SoulPlugin&gt;&gt; plugins) {
        List&lt;SoulPlugin&gt; pluginList = plugins.getIfAvailable(Collections::emptyList);
        final List&lt;SoulPlugin&gt; soulPlugins = pluginList.stream()
                .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList());
        soulPlugins.forEach(soulPlugin -&gt; log.info(&quot;load plugin:[{}] [{}]&quot;, soulPlugin.named(), soulPlugin.getClass().getName()));
        return new SoulWebHandler(soulPlugins);
    }
</code></pre><p>初始化<code>SoulWebHandler</code>的时候，将排好序的插件传入其构造函数中。各个插件都有一个order属性，可以根据这个属性来对插件进行优先级排序。以<code>DividePlugin</code>为例，看下它的order属性是从一个枚举类里面来的。</p><pre><code>    @Override
    public int getOrder() {
        return PluginEnum.DIVIDE.getCode();
    }
</code></pre><p>而各个插件的order的具体值是在<code>soul-common/src/main/java/org/dromara/soul/common/enums/PluginEnums</code>这个枚举类里面定义的。PluginEnum的code即为各个插件的order。</p><p><img src="https://img-blog.csdnimg.cn/20210115231323717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center" alt=PluginEnum的定义>
插件的顺序为：<code>global -&gt; sign -&gt; waf -&gt; rate-limiter -&gt; hystrix -&gt; resilience4j -&gt; divide -&gt; webClient -&gt; …………</code></p><p>每次有一个请求的时候，WebHandler即SoulWebHandler的<code>handle</code>方法都会被调用，该方法里面最主要的就是初始化了一个插件链<code>DefaultSoulPluginChain</code>，并执行该插件链。</p><p><img src="https://img-blog.csdnimg.cn/20210115231406346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center" alt=插件链的初始化></p><p>看一下<code>DefaultSoulPluginChain</code>的<code>execute</code>方法，里面遍历所有插件，依次调用插件的<code>execute</code>方法。</p><pre><code>    @Override
    public Mono&lt;Void&gt; execute(final ServerWebExchange exchange) {
        return Mono.defer(() -&gt; {
            if (this.index &lt; plugins.size()) {
                SoulPlugin plugin = plugins.get(this.index++);
                Boolean skip = plugin.skip(exchange);
                if (skip) {
                    return this.execute(exchange);
                }
                return plugin.execute(exchange, this);
            }
            return Mono.empty();
        });
    }
</code></pre><p>我们看一下<code>DividePlugin</code>的<code>execute</code>方法里面具体做了什么，从源码中看到<code>DividePlugin</code>并没有Override父类的<code>execute</code>方法。所以我们去父类<code>AbstractSoulPlugin</code>里面看一下<code>execute</code>方法具体做了什么。可以从下图看到，获取到了selector和rule，以便执行divide插件的doExecute方法。</p><p><img src="https://img-blog.csdnimg.cn/20210115231447528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center" alt=AbstractSoulPlugin的execute></p><h2 id=选择器与规则>选择器与规则</h2><p>下面介绍一下<code>选择器（Selector）</code>和<code>规则 (Rule)</code>两个概念。</p><p>官方文档里面介绍到，“选择器相当于是对流量的第一次筛选，规则就是最终的筛选“</p><p>看一下soul-admin管理后台的divide这个tab，可以看到<a href=https://blog.csdn.net/pcmmcpmorse/article/details/112646476>上一篇笔记</a>里面启动的soul-example-http服务的一些API被映射到了选择器和规则里面。</p><p><img src="https://img-blog.csdnimg.cn/20210115231526336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center" alt="soul-admin 管理后台的selector rule"></p><p>设想一下，你在网上买了东西，填收货地址的时候，大多数的交互都是让你<code>省-&gt;市</code>级联选择，极少数的交互是直接给你一个按首字母索引的全国城市列表来选择。</p><p><code>选择器-&gt;规则</code>类似于是<code>省-&gt;市</code>，http流量到网关的时候，网关先使用<code>选择器</code>来匹配，然后再进一步使用<code>规则</code>来匹配。这样做的好处应该是当网关有几百个下游业务(几万/几十万个API)的时候，可以比较快速地匹配到请求应该被转发的地址。</p><p>一般情况下，可以认为一个spring boot是一个业务，<code>选择器</code>里面可以初步匹配业务的名字，<code>规则</code>可以匹配业务的具体API。例如我有业务A、业务B都售卖API，那么就可以有<code>/businessA</code>、<code>/businessB</code>两个<code>选择器</code>。</p><p>上文提到，一个http请求过来了之后，从缓存里面获取到了与该url匹配的selector和rule，下面看下divide插件是怎么根据selector和rule进行http请求的代理转发的。</p><p><img src="https://img-blog.csdnimg.cn/20210115231612490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center" alt=DividePlugin的doExecute方法></p><p>从上图中可以看出，DividePlugin从selector和rule中根据负载均衡策略选择并拼装成真正的url，将真正的url和超时时间、重试次数这三个值放到了<code>ServerWebExchange</code>的<code>attribute</code>里面。</p><p>上文在插件链的顺序里面提到，divide的下一个插件是webClient。我们去<code>soul-plugin-httpclient/src/main/java/org/dromara/soul/plugin/httpClient/</code>里面看一下<code>WebClientPlugin</code>的execute方法。</p><p><img src="https://img-blog.csdnimg.cn/20210115231640417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center" alt=WebClientPlugin的execute方法></p><p>可以从上图看到，WebClientPlugin的execute方法里面，从exchange里面取出了HTTP_URL、HTTP_TIME_OUT、HTTP_RETRY，并发送了http请求。至此，一个外部的http请求就被网关真正代理到业务线去了。</p><p>本文就先到此，后续将学习soul网关的其他机制，如果时间富余的话要学习一下WebFlux框架相关的知识。</p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/zh/blog/soul_source_learning_02_divide_plugin/><span class=text>上一篇:</span>
<span class=text>Soul网关学习(2-1)Http代理之divide插件使用</span></a>
<a class=link-next href=/zh/blog/soul_source_learning_02_http_client_register/><span class=text>下一篇:</span>
<span class=text>Soul网关学习(2-3)Http客户端接入源码解析</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/zh/blog/soul_source_learning_02_divide_plugin/>Soul网关学习(2-1)Http代理之divide插件使用</a></li><li><a href=/zh/blog/soul_source_learning_01/>Soul网关学习(1)环境配置</a></li><li><a href=/zh/blog/soul_source_learning_05_plugin/>Soul网关学习插件链与负载均衡解析</a></li><li><a href=/zh/community/soul_2.2.0/>【Soul网关发布2.2.0】让高性能网关变得如此简单！</a></li><li><a href=/zh/community/soul_2.1.x/>Soul网关发布的2.1.X版本，到底有多方便？</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/dromara/>Dromara</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/hmily/>hmily</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/soul/>Soul</a></li><li class=tag><a href=/zh/tags/tcc/>TCC</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/shuaiqiyu>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/community>社区</a>
<a class=link href=/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/projects/soul/overview/>Soul</a>
<a class=link href=/projects/hmily/overview/>Hmily</a>
<a class=link href=/projects/raincat/overview/>Raincat</a>
<a class=link href=/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>