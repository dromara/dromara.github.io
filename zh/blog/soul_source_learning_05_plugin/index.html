<!doctype html><html><head><title>Soul网关学习插件链与负载均衡解析 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/zh/><img class=logo src=/img/logo.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/guides/><span>指南</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/soul_source_learning_05_plugin/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/>项目</a>
<a class=navbar-item href=/zh/guides/>指南</a>
<a class=navbar-item href=/zh/blog/>博客</a>
<a class=navbar-item href=/zh/activities/>活动</a>
<a class=navbar-item href=/zh/community/>社区</a>
<a class=navbar-item href=/zh/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/blog/soul_source_learning_05_plugin/>En</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Soul网关学习插件链与负载均衡解析</h1><div class=meta>2021-01-15 ·
朱明 ·
<span class=tags><a class=tag href=/zh/tags/soul/ rel=tag>#Soul</a></span></div></div><article class=typo><h1 id=插件链总结>插件链总结</h1><p>从一个类关系图说起:</p><p><img src=01.png alt=plugin关系图></p><p>其中两个最基本的插件类:</p><ul><li><p>SoulPlugin: 定义插件职责的接口, 重点方法<code>execute()</code> 被上层调用, <code>skip()</code> 方法可以使某些插件在某些请求中被跳过.</p></li><li><p>AbstractPlugin: 抽象类, 实现接口的 <code>execute()</code>, 定义一套通用的执行流程, 并使用模板方法的设计模式, 提供<code>doExecute()</code>抽象方法供实现类写自己的逻辑.</p></li></ul><h2 id=abstractsoulplugin>AbstractSoulPlugin</h2><p>具体分析下 <code>AbstractSoulPlugin</code> 类的 <code>execute()</code>:</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
  String pluginName = named();
  final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
  // 如果 pluginData.getEnabled() 为 false, 会直接跳到下个插件, 仅有为数不多的插件会进入这个条件判断 (DividePlugin、AlibabaDubboPlugin等)
  if (pluginData != null &amp;&amp; pluginData.getEnabled()) {
    // 获得插件上的所有选择器
    final Collection&lt;SelectorData&gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
    if (CollectionUtils.isEmpty(selectors)) {
      return CheckUtils.checkSelector(pluginName, exchange, chain);
    }
    // 检查上下文中的请求路径, 是否与选择器匹配, 并得到唯一一个匹配的选择器数据
    final SelectorData selectorData = matchSelector(exchange, selectors);
    if (Objects.isNull(selectorData)) {
      if (PluginEnum.WAF.getName().equals(pluginName)) {
        return doExecute(exchange, chain, null, null);
      }
      return CheckUtils.checkSelector(pluginName, exchange, chain);
    }
    if (selectorData.getLoged()) {
      log.info(&quot;{} selector success match , selector name :{}&quot;, pluginName, selectorData.getName());
    }
    // 获得选择器中的各个资源规则
    final List&lt;RuleData&gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
    if (CollectionUtils.isEmpty(rules)) {
      if (PluginEnum.WAF.getName().equals(pluginName)) {
        return doExecute(exchange, chain, null, null);
      }
      return CheckUtils.checkRule(pluginName, exchange, chain);
    }
    RuleData rule;
    if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
      rule = rules.get(rules.size() - 1);
    } else {
      // 匹配路径, 获得唯一一个规则
      rule = matchRule(exchange, rules);
    }
    if (Objects.isNull(rule)) {
      return CheckUtils.checkRule(pluginName, exchange, chain);
    }
    if (rule.getLoged()) {
      log.info(&quot;{} rule success match ,rule name :{}&quot;, pluginName, rule.getName());
    }
    // 执行子类的方法
    return doExecute(exchange, chain, selectorData, rule);
  }
  // 执行插件链上的下个插件
  return chain.execute(exchange);
}
</code></pre><p>通过代码分析, 可以得到一些结论:</p><ul><li>execute() 有两个逻辑: 一是请求路径与选择器和规则的匹配, 最终确认一个唯一规则, 并调用子类 doExecute(); 二是执行插件链上的下个插件.</li><li>execute() 实际抽象了一套规则匹配逻辑, 供所有&rdquo;转发类型&rdquo;的插件使用的, 转发类型的插件目前我了解的有 <code>DividePlugin</code> (http请求) 和 <code>AlibabaDubboPlugin</code> (dubbo请求), 其他类型的插件如果不重写 execute() 的方法, 会直接走入下个插件.</li></ul><h2 id=soulpluginchain>SoulPluginChain</h2><p>这里还有个点, 就是插件链的形成与链式调用, 我们来分析下 <code>SoulPluginChain</code> 这块:</p><p><img src=02.png alt=plugin02></p><p>SoulPluginChain 接口同样定义了 <code>execute()</code> 方法供调用者使用, 它的唯一子类 DefaultSoulPluginChain 实现了链式调用:</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange) {
  return Mono.defer(() -&gt; {
    // plugins 中包含所有网关加载的插件
    if (this.index &lt; plugins.size()) {
      // 每次调用execute()方法, index索引自增, 会调用到下一个插件
      SoulPlugin plugin = plugins.get(this.index++);
      // 结合上下文判断当前插件是否需要跳过
      Boolean skip = plugin.skip(exchange);
      if (skip) {
        return this.execute(exchange);
      } else {
        return plugin.execute(exchange, this);
      }
    } else {
      return Mono.empty();
    }
  });
}
</code></pre><p>看到这会很好奇 <code>plugins</code> 这个插件列表是哪里来的, 这里来解释下, DefaultSoulPluginChain 是 SoulWebHandler 的静态内部类, <code>plugins</code>就是 SoulWebHandle 中的一个属性:</p><pre><code class=language-java>public final class SoulWebHandler implements WebHandler {
    
    private List&lt;SoulPlugin&gt; plugins;

    public SoulWebHandler(final List&lt;SoulPlugin&gt; plugins) {
        this.plugins = plugins;
        // ...
    }
  
    @Override
    public Mono&lt;Void&gt; handle(@NonNull final ServerWebExchange exchange) {
                // ...
        return new DefaultSoulPluginChain(plugins).execute(exchange).subscribeOn(scheduler)
                .doOnSuccess(t -&gt; startTimer.ifPresent(time -&gt; MetricsTrackerFacade.getInstance().histogramObserveDuration(time)));
    }
  
    private static class DefaultSoulPluginChain implements SoulPluginChain {
    }
}
</code></pre><p>那么 SoulWebHandler 中的 <code>plugins</code> 又是怎么来的呢? 可以继续追溯下它构造器被调用的地方:</p><pre><code class=language-java>@Configuration
public class SoulConfiguration {
    
    @Bean(&quot;webHandler&quot;)
    public SoulWebHandler soulWebHandler(final ObjectProvider&lt;List&lt;SoulPlugin&gt;&gt; plugins) {
        List&lt;SoulPlugin&gt; pluginList = plugins.getIfAvailable(Collections::emptyList);
        final List&lt;SoulPlugin&gt; soulPlugins = pluginList.stream()
                .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList());
        soulPlugins.forEach(soulPlugin -&gt; log.info(&quot;loader plugin:[{}] [{}]&quot;, soulPlugin.named(), soulPlugin.getClass().getName()));
        return new SoulWebHandler(soulPlugins);
    }
}
</code></pre><p>可以看到是通过 Spring Bean的方式开始写入 <code>plugins</code>, 即在容器启动时, 加载了所有插件. 这里入口参数使用 <code>ObjectProvider</code> 就是延迟加载所有 SoulPlugin 类型的 Bean(若一个都没有也不会报错), 并注入到 SoulWebHandler 中.</p><p><strong>有个小坑需要注意 !</strong></p><p>包括 DividePlugin、AlibabaDubboPlugin等等的所有插件, 都是由各自的 <code>soul-spring-boot-starter-plugin-xx</code> 项目中的 XXPluginConfiguration 配置类, 注册自己的插件成为 Bean, 类似下面示例:</p><pre><code class=language-java>@Configuration
public class DividePluginConfiguration {

    @Bean
    public SoulPlugin dividePlugin() {
        return new DividePlugin();
    }
}
</code></pre><p>所以在网关项目 <code>soul-bootstrap</code> 中, 如果需要用到某个插件, 不仅仅是在管理后台开启这个插件, 还需要确认下 <code>soul-bootstrap</code> 的 <code>pom.xml</code> 中是否存在相关插件所在的 <code>soul-spring-boot-starter-plugin-xx</code> 依赖, 比如:</p><pre><code class=language-xml>&lt;dependency&gt;
  &lt;groupId&gt;org.dromara&lt;/groupId&gt;
  &lt;artifactId&gt;soul-spring-boot-starter-plugin-divide&lt;/artifactId&gt;
  &lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>如果这里你给注释了或者根本不存在, 不要幻想在插件链上看到它&hellip;</p><h2 id=插件项目结构>插件项目结构</h2><p>最后简单说下各个插件项目的功能:</p><ol><li><p>首先是刚刚提到的spring bean启动类项目 , 列出个大概:</p><pre><code>soul-spring-boot-starter-plugin-alibaba-dubbo
soul-spring-boot-starter-plugin-apache-dubbo
soul-spring-boot-starter-plugin-context-path
soul-spring-boot-starter-plugin-divide
soul-spring-boot-starter-plugin-global
soul-spring-boot-starter-plugin-httpclient
soul-spring-boot-starter-plugin-hystrix
soul-spring-boot-starter-plugin-monitor
soul-spring-boot-starter-plugin-ratelimiter
soul-spring-boot-starter-plugin-resilience4j
soul-spring-boot-starter-plugin-rewrite
soul-spring-boot-starter-plugin-sentinel
soul-spring-boot-starter-plugin-sign
soul-spring-boot-starter-plugin-sofa
soul-spring-boot-starter-plugin-springcloud
soul-spring-boot-starter-plugin-tars
soul-spring-boot-starter-plugin-waf
</code></pre></li></ol><p>它们的主要作用刚刚也提到了, 将自身的 SoulPlugin子类注册为 spring bean, 以及注册 spring bean 给 AbstractSoulPlugin 中调用到的 PluginDataHandler 接口, 提供自身的实现子类, 比如 DividePluginDataHandler.</p><ol><li><p>具体的插件类所在项目:</p><pre><code>soul-plugin-alibaba-dubbo
soul-plugin-apache-dubbo
soul-plugin-api
soul-plugin-base
soul-plugin-context-path
soul-plugin-divide
soul-plugin-global
soul-plugin-httpclient
soul-plugin-hystrix
soul-plugin-monitor
soul-plugin-ratelimiter
soul-plugin-resilience4j
soul-plugin-rewrite
soul-plugin-sentinel
soul-plugin-sign
soul-plugin-sofa
soul-plugin-springcloud
soul-plugin-tars
soul-plugin-waf
</code></pre></li></ol><p>拿 <code>soul-plugin-divide</code> 项目举例, 刚刚提到的 DividePlugin 与 DividePluginDataHandler 就在其中. 并且项目里还有节点信息缓存管理器 UpstreamCacheManager, 负载均衡策略类 LoadBalance 等等.</p><h1 id=divideplugin>DividePlugin</h1><p>DividePlugin 的作用是匹配 Http 请求, 既然有 Http 请求自然也有转发下游和返回响应, 所以这里我们会分析到三个插件: DividePlugin、WebClientPlugin、WebClientResponsePlugin.</p><p>首先来看 DividePlugin 中 <code>doExecute()</code> 具体实现, 这里我只保留了核心点:</p><pre><code class=language-java>@Override
protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {
  final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);
  final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class);
  // 通过选择器ID, 在缓存中得到服务节点集群
  final List&lt;DivideUpstream&gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId());
    // 调用负载均衡方法并传入策略类型, 得到唯一节点
  DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip);
    // 获得节点的真实url, 并放入 exchange 上下文中
  String domain = buildDomain(divideUpstream);
  String realURL = buildRealURL(domain, soulContext, exchange);
  exchange.getAttributes().put(Constants.HTTP_URL, realURL);
  // 继续调用下个插件
  return chain.execute(exchange);
}
</code></pre><p>可以看到, 在执行完 DividePlugin 的 <code>doExecute()</code> 方法后, 我们的 ServerWebExchange 上下文中已经有了下游服务节点的真实路径, 接下来只要请求它就搞定. 不过先别着急, 这里的负载均衡策略也是关键点, 接着分析下.</p><h2 id=负载均衡>负载均衡</h2><p>Soul网关的负载均衡如何执行, 不止涉及到各种策略 (hasn、随机、轮询), 也涉及到 &ldquo;权重分数&rdquo; 这个概念, 管理后台的具体配置如下:</p><p><img src=/img/soul/blog1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptNDY5NTY4NTk1,size_16,color_FFFFFF,t_70.png alt></p><p><img src=/img/soul/blog1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ptNDY5NTY4NTk1,size_16,color_FFFFFF,t_70-20210118110416590.png alt></p><p><img src=/img/soul/blog1/image-20210118113516468.png alt=image-20210118113516468></p><p>展示完后台配置, 我们具体看看各个策略的代码实现.</p><h2 id=hash>Hash</h2><pre><code class=language-java>public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {
  final ConcurrentSkipListMap&lt;Long, DivideUpstream&gt; treeMap = new ConcurrentSkipListMap&lt;&gt;();
  for (DivideUpstream address : upstreamList) {
    // 每个节点*VIRTUAL_NODE_NUM(默认5), 使hash更加均匀
    for (int i = 0; i &lt; VIRTUAL_NODE_NUM; i++) {
      long addressHash = hash(&quot;SOUL-&quot; + address.getUpstreamUrl() + &quot;-HASH-&quot; + i);
      treeMap.put(addressHash, address);
    }
  }
  // 从当前ip得到一个hash值, 并比对treemap(有序), 找到大于此hash值的位置
  long hash = hash(String.valueOf(ip));
  SortedMap&lt;Long, DivideUpstream&gt; lastRing = treeMap.tailMap(hash);
  // 只要服务节点不增减, 同一个ip得到的节点就可以保持不变
  if (!lastRing.isEmpty()) {
    return lastRing.get(lastRing.firstKey());
  }
  return treeMap.firstEntry().getValue();
}
</code></pre><p>hash算法的负载均衡, 并没有使用到 &ldquo;权重分数&rdquo; 这个概念, 也就是说针对每个未知的 IP 各个节点被访问的可能性是一致的. (当然, 同一个 IP 多次调用只会访问同个节点)</p><h2 id=randomloadbalance>RandomLoadBalance</h2><pre><code class=language-java>public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {
  // 总个数
  int length = upstreamList.size();
  // 总权重
  int totalWeight = 0;
  // 权重是否都一样
  boolean sameWeight = true;
  for (int i = 0; i &lt; length; i++) {
    int weight = upstreamList.get(i).getWeight();
    // 累计总权重
    totalWeight += weight;
    if (sameWeight &amp;&amp; i &gt; 0
        &amp;&amp; weight != upstreamList.get(i - 1).getWeight()) {
      // 计算所有权重是否一样
      sameWeight = false;
    }
  }
  if (totalWeight &gt; 0 &amp;&amp; !sameWeight) {
    // 如果权重不相同且权重大于0则按总权重数随机
    int offset = RANDOM.nextInt(totalWeight);
    // 并确定随机值落在哪个片断上
    for (DivideUpstream divideUpstream : upstreamList) {
      offset -= divideUpstream.getWeight();
      if (offset &lt; 0) {
        return divideUpstream;
      }
    }
  }
  // 如果权重相同或权重为0则均等随机
  return upstreamList.get(RANDOM.nextInt(length));
}
</code></pre><p>当使用 <code>random</code> 规则时, 所有节点权重分累加并随机得到数字, 看具体是落在那个节点的权重片段上; 如果分数0或者相同则很直接的随机集群长度即可.</p><h2 id=roundrobinloadbalance>RoundRobinLoadBalance</h2><pre><code class=language-java>public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {
  String key = upstreamList.get(0).getUpstreamUrl();
  ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);
  if (map == null) {
    methodWeightMap.putIfAbsent(key, new ConcurrentHashMap&lt;&gt;(16));
    map = methodWeightMap.get(key);
  }
  int totalWeight = 0;
  long maxCurrent = Long.MIN_VALUE;
  long now = System.currentTimeMillis();
  DivideUpstream selectedInvoker = null;
  WeightedRoundRobin selectedWRR = null;
  for (DivideUpstream upstream : upstreamList) {
    String rKey = upstream.getUpstreamUrl();
    // 取出节点在缓存中的信息
    WeightedRoundRobin weightedRoundRobin = map.get(rKey);
    int weight = upstream.getWeight();
    if (weightedRoundRobin == null) {
      weightedRoundRobin = new WeightedRoundRobin();
      weightedRoundRobin.setWeight(weight);
      map.putIfAbsent(rKey, weightedRoundRobin);
    }
    if (weight != weightedRoundRobin.getWeight()) {
      weightedRoundRobin.setWeight(weight);
    }
    // 这里是第一个关键: 缓存中的分数增加当前节点权重分
    long cur = weightedRoundRobin.increaseCurrent();
    weightedRoundRobin.setLastUpdate(now);
    // 选择缓存分值高的节点
    if (cur &gt; maxCurrent) {
      maxCurrent = cur;
      selectedInvoker = upstream;
      selectedWRR = weightedRoundRobin;
    }
    totalWeight += weight;
  }
  if (!updateLock.get() &amp;&amp; upstreamList.size() != map.size() &amp;&amp; updateLock.compareAndSet(false, true)) {
    try {
      ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = new ConcurrentHashMap&lt;&gt;(map);
      newMap.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; recyclePeriod);
      methodWeightMap.put(key, newMap);
    } finally {
      updateLock.set(false);
    }
  }
  if (selectedInvoker != null) {
    // 这里是第二个关键: 缓存中的分数, 减少总节点权重分
    selectedWRR.sel(totalWeight);
    return selectedInvoker;
  }
  return upstreamList.get(0);
}
</code></pre><p>这个算法有点复杂, 我解释下核心计算权重的方面:</p><ul><li>两个分值分别为2、100的节点进入, 缓存中保留它们各自, 分值从0开始</li><li>经过for循环后, 两个节点在缓存中的分值会以自身为基数增加, 假设后面步骤不进行, 则缓存第一次为2、100, 第二次为4、200, 依次类推.</li><li>关键的第三步, 选出节点缓存中分值最高的, 进行&rdquo;处罚&rdquo;措施, 减少所有节点的累计分值, 即102.</li></ul><p>根据这个算法的步骤, 一直没有被选中的节点, 作为&rdquo;成长奖励&rdquo;, 会持续以自身为基数自增; 而被选中的节点, 作为&rdquo;惩罚&rdquo;, 会减少其他节点的权重分之和.</p><p>可以预见, 权重分小的节点, 要自增到很久之后, 才会等来自身被选中的一刻, 然而那一刻它被惩罚的力度会非常大, 导致它一朝回到解放前, 又要开始漫长的积蓄力量. 而权重分大的节点, 每次被选上的惩罚力度很小, 即使多次后分数太低没被选上, 他的奖励分数(自身)也特别高, 一次增加就远远超越其他节点.</p><h2 id=webclientplugin>WebClientPlugin</h2><p>经过 DividePlugin 插件的调用后, 下游服务节点路径被确定, 接着就是 WebClientPlugin 插件发挥作用了. 它直接实现了 SoulPlugin 接口并实现了 <code>execute()</code> 方法 (仅保留核心代码):</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
  String urlPath = exchange.getAttribute(Constants.HTTP_URL);
  // 请求类型: Get请求orPost请求等
  HttpMethod method = HttpMethod.valueOf(exchange.getRequest().getMethodValue());
  // 构建一个请求对象空壳, 注入请求类型和URL
  WebClient.RequestBodySpec requestBodySpec = webClient.method(method).uri(urlPath);
  return handleRequestBody(requestBodySpec, exchange, timeout, chain);
}

private Mono&lt;Void&gt; handleRequestBody(final WebClient.RequestBodySpec requestBodySpec,
                                         final ServerWebExchange exchange,
                                         final long timeout,
                                         final SoulPluginChain chain) {
  return requestBodySpec.headers(httpHeaders -&gt; {
    // 补充上下文中请求头... 后面也是补充些属性, 不赘述
    httpHeaders.addAll(exchange.getRequest().getHeaders());
    httpHeaders.remove(HttpHeaders.HOST);
  })
    .contentType(buildMediaType(exchange))
    .body(BodyInserters.fromDataBuffers(exchange.getRequest().getBody()))
    // 开始异步http调用下游服务
    .exchange()
    .doOnError(e -&gt; log.error(e.getMessage()))
    .timeout(Duration.ofMillis(timeout))
    // 回调接收返回值
    .flatMap(e -&gt; doNext(e, exchange, chain));
}

// 这里是异步的回调方法, 在另一个线程中工作
private Mono&lt;Void&gt; doNext(final ClientResponse res, final ServerWebExchange exchange, final SoulPluginChain chain) {
  // ...
  // 继续完成剩下的插件链调用
  return chain.execute(exchange);
}
</code></pre><p>简单看下 <code>handleRequestBody()</code> 中 <code>exchange()</code> 这个方法的实现, 这里有关键的Http调用:</p><pre><code class=language-java>class DefaultWebClient implements WebClient {
  @Override
  public Mono&lt;ClientResponse&gt; exchange() {
    ClientRequest request = (this.inserter != null ?
                             initRequestBuilder().body(this.inserter).build() :
                             initRequestBuilder().build());
    // 这里是关键调用, 会走到 spring-web-reactive
    return Mono.defer(() -&gt; exchangeFunction.exchange(request)
                      .checkpoint(&quot;Request to &quot; + this.httpMethod.name() + &quot; &quot; + this.uri + &quot; [DefaultWebClient]&quot;)
                      .switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR));
  }
}
</code></pre><p>总结下, 经过 WebClientPlugin 的处理会异步调用下游服务, 等待响应后再在另一个线程中, 执行后续的插件链调用.</p><h2 id=webclientresponseclient>WebClientResponseClient</h2><p>最后插件链走到 WebClientResponseClient 这一环, 封装响应信息:</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
  return chain.execute(exchange).then(Mono.defer(() -&gt; {
    // 获取上下文中存放的响应信息
    ServerHttpResponse response = exchange.getResponse();
    ClientResponse clientResponse = exchange.getAttribute(Constants.CLIENT_RESPONSE_ATTR);
    if (Objects.isNull(clientResponse)
        || response.getStatusCode() == HttpStatus.BAD_GATEWAY
        || response.getStatusCode() == HttpStatus.INTERNAL_SERVER_ERROR) {
      Object error = SoulResultWarp.error(SoulResultEnum.SERVICE_RESULT_ERROR.getCode(), SoulResultEnum.SERVICE_RESULT_ERROR.getMsg(), null);
      return WebFluxResultUtils.result(exchange, error);
    } else if (response.getStatusCode() == HttpStatus.GATEWAY_TIMEOUT) {
      Object error = SoulResultWarp.error(SoulResultEnum.SERVICE_TIMEOUT.getCode(), SoulResultEnum.SERVICE_TIMEOUT.getMsg(), null);
      return WebFluxResultUtils.result(exchange, error);
    }
    // 各种拼装
    response.setStatusCode(clientResponse.statusCode());
    response.getCookies().putAll(clientResponse.cookies());
    response.getHeaders().putAll(clientResponse.headers().asHttpHeaders());
    return response.writeWith(clientResponse.body(BodyExtractors.toDataBuffers()));
  }));
}
</code></pre></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/zh/blog/hmily_current/><span class=text>上一篇:</span>
<span class=text>Hmily: 轻松搞定高并发分布式事务</span></a>
<a class=link-next href=/zh/blog/soul_source_learning_01/><span class=text>下一篇:</span>
<span class=text>Soul网关学习(1)环境配置</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/zh/blog/soul_source_learning_01/>Soul网关学习(1)环境配置</a></li><li><a href=/zh/community/soul-2.2.0/>【Soul网关发布2.2.0】让高性能网关变得如此简单！</a></li><li><a href=/zh/community/soul-2.1.x/>Soul网关发布的2.1.X版本，到底有多方便？</a></li><li><a href=/zh/community/soul-1.0.4/>Soul网关发布1.0.4-RELEASE版本</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/dromara/>Dromara</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/hmily/>hmily</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/soul/>Soul</a></li><li class=tag><a href=/zh/tags/tcc/>TCC</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/shuaiqiyu>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/zh/community>社区</a>
<a class=link href=/zh/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/zh/projects/soul/overview/>Soul</a>
<a class=link href=/zh/projects/hmily/overview/>Hmily</a>
<a class=link href=/zh/projects/raincat/overview/>Raincat</a>
<a class=link href=/zh/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>