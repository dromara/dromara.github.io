<!doctype html><html><head><title>Soul网关学习Http长轮询解析02 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?a02cb5c75097762223d5a815a03e0a15";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/zh/><img class=logo src=/img/logo/dromara.jpg></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/guides/><span>指南</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/soul_source_learning_09_httplongpolling_02/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/>项目</a>
<a class=navbar-item href=/zh/guides/>指南</a>
<a class=navbar-item href=/zh/blog/>博客</a>
<a class=navbar-item href=/zh/activities/>活动</a>
<a class=navbar-item href=/zh/community/>社区</a>
<a class=navbar-item href=/zh/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/blog/soul_source_learning_09_httplongpolling_02/>En</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Soul网关学习Http长轮询解析02</h1><div class=meta>2021-01-27 ·
朱明 ·
<span class=tags><a class=tag href=/zh/tags/soul/ rel=tag>#Soul</a></span></div></div><article class=typo><h2 id=后台与网关数据同步-http长轮询篇>后台与网关数据同步 (Http长轮询篇)</h2><p>长轮询分析的最后一篇, 总结网关端的长轮询的实现, 以及数据流动方式.</p><p>网关端长轮询的流程总体也分两个模块: 一是启动时拉取, 二是轮询监听变化</p><h2 id=网关启动时拉取数据>网关启动时拉取数据</h2><p>网关启动后, 会调用后台提供的接口拉取数据, 并将数据发送到各个插件的数据处理类中</p><p>下面展示下网关启动拉取数据的处理流程:
<img src=/img/soul/blog1/01.png alt=01></p><p>这几个处理步骤被分散到下面这些类的方法协作中:</p><p><img src=/img/soul/blog1/02.png alt=02></p><p>HttpSyncDataService#start: 网关启动时, HttpSyncDataService 初始化会调用 <code>start()</code> 方法, 该方法会调用后台拉取数据, 并开启多个线程进行轮询监听 (这块在下个模块分析)</p><pre><code class=language-java>public class HttpSyncDataService implements SyncDataService, AutoCloseable {
  
  private void start() {
    // 防止二次调用的CAS操作
    if (RUNNING.compareAndSet(false, true)) {
      // 这里是本次流程的重点, 调用拉取数据的方法
      this.fetchGroupConfig(ConfigGroupEnum.values());
      int threadSize = serverList.size();
      // 这里将在下个模块分析, 会根据后台集群开启线程轮询监听
      this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,
                                             new LinkedBlockingQueue&lt;&gt;(),
                                             SoulThreadFactory.create(&quot;http-long-polling&quot;, true));
      this.serverList.forEach(server -&gt; this.executor.execute(new HttpLongPollingTask(server)));
    } else {
      log.info(&quot;soul http long polling was started, executor=[{}]&quot;, executor);
    }
  }
}
</code></pre><p>HttpSyncDataService#fetchGroupConfig: 作用仅是根据数据类型, 循环多次调用拉取数据方法(针对同一个后台会请求多次, 每次拉取某一种数据类型的信息), 这里的数据类型指的是 plugin、rule、selector 等</p><pre><code class=language-java>private void fetchGroupConfig(final ConfigGroupEnum... groups) throws SoulException {
  for (int index = 0; index &lt; this.serverList.size(); index++) {
    String server = serverList.get(index);
    try {
            // 根据传入的数据类型枚举, 多次调用拉取数据方法
      this.doFetchGroupConfig(server, groups);
      break;
    } catch (SoulException e) {
      if (index &gt;= serverList.size() - 1) {
        throw e;
      }
      log.warn(&quot;fetch config fail, try another one: {}&quot;, serverList.get(index + 1));
    }
  }
}
</code></pre><p>HttpSyncDataService#doFetchGroupConfig: 请求后台的 <code>/configs/fetch</code> 接口, 拿到某个类型的数据, 并更新缓存. 更新缓存前会检测是否变动, 如果变动则结束, <strong>数据未发生变动则睡眠30s</strong> (由于是第一次启动, 数据为空的情况下肯定会更新缓存, 所以会直接结束)</p><pre><code class=language-java>private void doFetchGroupConfig(final String server, final ConfigGroupEnum... groups) {
  StringBuilder params = new StringBuilder();
  for (ConfigGroupEnum groupKey : groups) {
    params.append(&quot;groupKeys&quot;).append(&quot;=&quot;).append(groupKey.name()).append(&quot;&amp;&quot;);
  }
  // 具体请求路径, 拉取后台数据
  String url = server + &quot;/configs/fetch?&quot; + StringUtils.removeEnd(params.toString(), &quot;&amp;&quot;);
  log.info(&quot;request configs: [{}]&quot;, url);
  String json = null;
  try {
    json = this.httpClient.getForObject(url, String.class);
  } catch (RestClientException e) {
    String message = String.format(&quot;fetch config fail from server[%s], %s&quot;, url, e.getMessage());
    log.warn(message);
    throw new SoulException(message, e);
  }
  // 修改缓存信息
  boolean updated = this.updateCacheWithJson(json);
  // 判断是否修改, 修改则直接结束
  if (updated) {
    log.info(&quot;get latest configs: [{}]&quot;, json);
    return;
  }
  log.info(&quot;The config of the server[{}] has not been updated or is out of date. Wait for 30s to listen for changes again.&quot;, server);
  ThreadUtils.sleep(TimeUnit.SECONDS, 30);
}
</code></pre><p>HttpSyncDataService#updateCacheWithJson: 取出响应信息中的 <code>data</code> , 即变化的数据信息, 传给数据刷新工厂 DataRefreshFactory</p><pre><code class=language-java>private DataRefreshFactory factory;

public HttpSyncDataService(...){
  this.factory = new DataRefreshFactory(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);
}

private boolean updateCacheWithJson(final String json) {
  JsonObject jsonObject = GSON.fromJson(json, JsonObject.class);
  JsonObject data = jsonObject.getAsJsonObject(&quot;data&quot;);
  return factory.executor(data);
}
</code></pre><p>DataRefreshFactory#executor: 将数据发送给各类数据刷新类 (这里没有去区别信息类型, 而是通知所有数据刷新类, 可考虑优化)</p><pre><code class=language-java>public final class DataRefreshFactory {

  private static final EnumMap&lt;ConfigGroupEnum, DataRefresh&gt; ENUM_MAP = new EnumMap&lt;&gt;(ConfigGroupEnum.class);

  public DataRefreshFactory(final PluginDataSubscriber pluginDataSubscriber,
                              final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,
                              final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {
    // 注入各类型订阅器到 MAP 中
    ENUM_MAP.put(ConfigGroupEnum.PLUGIN, new PluginDataRefresh(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.SELECTOR, new SelectorDataRefresh(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.RULE, new RuleDataRefresh(pluginDataSubscriber));
    ENUM_MAP.put(ConfigGroupEnum.APP_AUTH, new AppAuthDataRefresh(authDataSubscribers));
    ENUM_MAP.put(ConfigGroupEnum.META_DATA, new MetaDataRefresh(metaDataSubscribers));
  }
  
  public boolean executor(final JsonObject data) {
    final boolean[] success = {false};
    // Tureen: 所有数据类型的 DataRefresh 全调用
    ENUM_MAP.values().parallelStream().forEach(dataRefresh -&gt; success[0] = dataRefresh.refresh(data));
    return success[0];
  } 
}
</code></pre><p>AbstractDataRefresh#refresh: 判断是否要更新缓存, 若更新则调用各类型的 <code>refresh()</code> 方法</p><pre><code class=language-java>@Override
public Boolean refresh(final JsonObject data) {
  boolean updated = false;
  JsonObject jsonObject = convert(data);
  if (null != jsonObject) {
    ConfigData&lt;T&gt; result = fromJson(jsonObject);
    if (this.updateCacheIfNeed(result)) {
      updated = true;
      // Turren: 调用 refresh
      refresh(result.getData());
    }
  }
  return updated;
}
</code></pre><p>PluginDataRefresh#refresh: 调用 plugin 的订阅器, 接下来会通知所有扩展插件的相关事件变动</p><pre><code class=language-java>@Override
protected void refresh(final List&lt;PluginData&gt; data) {
  if (CollectionUtils.isEmpty(data)) {
    log.info(&quot;clear all plugin data cache&quot;);
    pluginDataSubscriber.refreshPluginDataAll();
  } else {
    pluginDataSubscriber.refreshPluginDataAll();
    // Turren: http同步, 调用插件数据订阅器
    data.forEach(pluginDataSubscriber::onSubscribe);
  }
}
</code></pre><h2 id=网关轮询监听变化>网关轮询监听变化</h2><p>网关启动时, 同时也开启了线程做后台监听请求, 监听请求做了while死循环来轮询, 在后台端会劫持住请求, 这块在后台总结中有具体分析 (<a href=https://blog.csdn.net/zm469568595/article/details/113207367>后台与网关数据同步 (Http长轮询篇 &lt;二&gt;)</a>)</p><p>下面展示下网关监听数据变动的整体流程:</p><p><img src=/img/soul/blog1/03.png alt=03></p><p>对应的实际代码实现如下:</p><p><img src=/img/soul/blog1/04.png alt=04></p><p><strong>网关端监听的流程实现都在 HttpSyncDataService 类中, 在最后会经由 <code>doFetchGroupConfig()</code> 传到到各类订阅器, 后面的流程与启动时的一致</strong></p><p>HttpSyncDataService#start: 启动线程执行 HttpLongPollingTask 这个 Runnable</p><p>HttpLongPollingTask#run: 开启循环调用轮询方法.</p><pre><code class=language-java>@Override
public void run() {
  while (RUNNING.get()) {
    for (int time = 1; time &lt;= retryTimes; time++) {
      try {
        doLongPolling(server);
      } catch (Exception e) {
        if (time &lt; retryTimes) {
          log.warn(&quot;Long polling failed, tried {} times, {} times left, will be suspended for a while! {}&quot;,
                   time, retryTimes - time, e.getMessage());
          ThreadUtils.sleep(TimeUnit.SECONDS, 5);
          continue;
        }
        log.error(&quot;Long polling failed, try again after 5 minutes!&quot;, e);
        ThreadUtils.sleep(TimeUnit.MINUTES, 5);
      }
    }
  }
}
</code></pre><p>HttpLongPollingTask#doLongPolling: 得到监听请求的响应结果, 如果返回值中有变化的类型, 则调用数据拉取方法.</p><pre><code class=language-java>private void doLongPolling(final String server) {
  // 从缓存中获取数据
  MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;(8);
  for (ConfigGroupEnum group : ConfigGroupEnum.values()) {
    ConfigData&lt;?&gt; cacheConfig = factory.cacheConfigData(group);
    String value = String.join(&quot;,&quot;, cacheConfig.getMd5(), String.valueOf(cacheConfig.getLastModifyTime()));
    params.put(group.name(), Lists.newArrayList(value));
  }
  // 构建 http 请求信息
  HttpHeaders headers = new HttpHeaders();
  headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
  HttpEntity httpEntity = new HttpEntity(params, headers);
  String listenerUrl = server + &quot;/configs/listener&quot;;
  log.debug(&quot;request listener configs: [{}]&quot;, listenerUrl);
  JsonArray groupJson = null;
  try {
    String json = this.httpClient.postForEntity(listenerUrl, httpEntity, String.class).getBody();
    groupJson = GSON.fromJson(json, JsonObject.class).getAsJsonArray(&quot;data&quot;);
  } catch (RestClientException e) {
    String message = String.format(&quot;listener configs fail, server:[%s], %s&quot;, server, e.getMessage());
    throw new SoulException(message, e);
  }
  // 得到变化的类型
  if (groupJson != null) {
    ConfigGroupEnum[] changedGroups = GSON.fromJson(groupJson, ConfigGroupEnum[].class);
    if (ArrayUtils.isNotEmpty(changedGroups)) {
      log.info(&quot;Group config changed: {}&quot;, Arrays.toString(changedGroups));
      // 拉取后台对应类型的数据
      this.doFetchGroupConfig(server, changedGroups);
    }
  }
}
</code></pre><p>LongPollingClient#doFetchGroupConfig:</p><p>之前的启动里分析了这块的代码, 它与启动里最不同的点是, <strong>如果拉取的数据与缓存比对后, 发现没有变化则睡眠30s, 会导致下次的监听延后30s</strong>.</p><p>什么意思呢? 如果网关去 <code>fetch</code> 后台的数据, 拿回来比对后发现被骗了! 啥变化也没有, 就等30s 再启动下次监听, 这个期间如果后台发生数据变化肯定是没法通知到网关的.</p><p>网关为什么这么做? 自然是为了防止大量的循环的无用拉取, 如果后台出现问题不断的通知数据变动, 但实际没有任何变动, 那么网关不延迟就会与后台产生大量无用的 网络IO 与 数据交换</p></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/zh/blog/soul_source_learning_17_http/><span class=text>上一篇:</span>
<span class=text>Soul网关学习Http请求探险</span></a>
<a class=link-next href=/zh/blog/soul_source_learning_12_sign/><span class=text>下一篇:</span>
<span class=text>Soul网关学习Sign插件</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/zh/blog/soul_source_learning_17_http/>Soul网关学习Http请求探险</a></li><li><a href=/zh/blog/soul_source_learning_14_nacos/>Soul网关学习Nacos数据同步</a></li><li><a href=/zh/blog/soul_source_learning_08_httplongpolling_01/>Soul网关学习Http长轮询解析01</a></li><li><a href=/zh/blog/soul_source_learning_10_websocket/>Soul网关学习WebSocket数据同步解析</a></li><li><a href=/zh/activities/dromara-cloud-native-meet/>Dromara Soul 源码01期阅读分享会01</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/dromara/>Dromara</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/hmily/>hmily</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/soul/>Soul</a></li><li class=tag><a href=/zh/tags/tcc/>TCC</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/dromara>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/zh/community>社区</a>
<a class=link href=/zh/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/zh/projects/soul/overview/>Soul</a>
<a class=link href=/zh/projects/hmily/overview/>Hmily</a>
<a class=link href=/zh/projects/raincat/overview/>Raincat</a>
<a class=link href=/zh/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>