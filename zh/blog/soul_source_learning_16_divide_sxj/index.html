<!doctype html><html><head><title>Soul网关学习divide插件源码解读 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?a02cb5c75097762223d5a815a03e0a15";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/zh/><img class=logo src=/img/logo/dromara.jpg></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/soul_source_learning_16_divide_sxj/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/>项目</a>
<a class=navbar-item href=/zh/blog/>博客</a>
<a class=navbar-item href=/zh/activities/>活动</a>
<a class=navbar-item href=/zh/community/>社区</a>
<a class=navbar-item href=/zh/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/blog/soul_source_learning_16_divide_sxj/>En</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Soul网关学习divide插件源码解读</h1><div class=meta>2021-02-01 ·
沈祥俊 ·
<span class=tags><a class=tag href=/zh/tags/soul/ rel=tag>#Soul</a></span></div></div><article class=typo><h2 id=插件概述>插件概述</h2><p><strong>插件定位</strong></p><p>divide 插件是一个 http 正向代理插件，所有的 http 请求都由该插件进行负载均衡处理（具体的负载均衡策略在规则中指定）。</p><p><strong>生效时机</strong></p><p>当请求头的 rpcType = http 且插件开启时，它将根据请求参数匹配规则，最终交由下游插件进行响应式代理调用。</p><h2 id=插件处理流程>插件处理流程</h2><p>1）先回顾下请求处理类插件的通用流程（AbstractSoulPlugin # execute）：</p><pre><code class=language-java>public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
    // 获取插件数据
    String pluginName = named();
    final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
    if (pluginData != null &amp;&amp; pluginData.getEnabled()) {
        // 获取选择器数据
        final Collection&lt;SelectorData&gt; selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
        ...
        // 匹配选择器
        final SelectorData selectorData = matchSelector(exchange, selectors);
        ...
        // 获取规则数据
        final List&lt;RuleData&gt; rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
        ...
        // 匹配规则
        RuleData rule;
        if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
            //get last
            rule = rules.get(rules.size() - 1);
        } else {
            rule = matchRule(exchange, rules);
        }
        ...
        // 执行自定义处理
        return doExecute(exchange, chain, selectorData, rule);
    }
    // 继续执行插件链处理
    return chain.execute(exchange);
}
</code></pre><p>AbstractSoulPlugin 先匹配到对应的选择器和规则，匹配通过则执行插件的自定义处理。</p><p>2）再来看看 divide 插件的自定义处理流程（DividePlugin # doExecute）：</p><pre><code class=language-java>protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {
    ...
    // 准备规则处理对象（内部持有：负载均衡算法名、重试次数以及超时时间）
    final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class);
    // 获取选择器对应的可用服务列表
    final List&lt;DivideUpstream&gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId());
    ...
    // 选择具体分发的服务实例ip（负载均衡）
    final String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();
    DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip);
    ...
    //设置 http url、超时时间以及重试次数
    String domain = buildDomain(divideUpstream);
    String realURL = buildRealURL(domain, soulContext, exchange);
    exchange.getAttributes().put(Constants.HTTP_URL, realURL);
    exchange.getAttributes().put(Constants.HTTP_TIME_OUT, ruleHandle.getTimeout());
    exchange.getAttributes().put(Constants.HTTP_RETRY, ruleHandle.getRetry());
    // 继续执行插件链处理
    return chain.execute(exchange);
}
</code></pre><p>DividePlugin 先获取到选择器对应的可用服务列表，然后进行负载均衡选择即将分发的目标服务器实例ip，最后设置最终的 url、超时时间以及重试次数并交由插件链下游进行处理。</p><p><strong>注意：</strong></p><p>divide 插件自身只是负责根据选择器、规则和负载均衡策略选出待分发的服务器实例，并不直接向后端服务发起 http 请求。</p><h2 id=主机探活>主机探活</h2><p>上面提到，divide 需要获取服务列表，看下获取的实现（UpstreamCacheManager # findUpstreamListBySelectorId）：</p><pre><code class=language-java>public List&lt;DivideUpstream&gt; findUpstreamListBySelectorId(final String selectorId) {
    return UPSTREAM_MAP_TEMP.get(selectorId);
}
</code></pre><p>内部通过 UPSTREAM_MAP_TEMP 获取存活服务列表。</p><p>UpstreamCacheManager 内部维护了两份散列表：</p><ul><li>UPSTREAM_MAP：</li></ul><p>全量服务散列表，负责存放全量的上游服务信息，key 为 选择器 id，value 为使用相同选择器的服务列表。</p><ul><li>UPSTREAM_MAP_TEMP：</li></ul><p>临时服务散列表，负责存放活动的上游服务信息，key 为 选择器 id，value 为使用相同选择器的服务列表。</p><p>前面章节我们提到，数据同步时，submit 方法同时更新了 UPSTREAM_MAP 和 UPSTREAM_MAP_TEMP，但后续服务下线如何维护 UPSTREAM_MAP_TEMP 呢，一切还得从 ip 探活说起。</p><h4 id=3-1-探活时机>3.1 探活时机</h4><p>探活时机得从 UpstreamCacheManager 初始化说起：</p><pre><code class=language-java>private UpstreamCacheManager() {
    // 探活开关检查
    boolean check = Boolean.parseBoolean(System.getProperty(&quot;soul.upstream.check&quot;, &quot;false&quot;));
    if (check) {
        // 启动定时探活任务
        new ScheduledThreadPoolExecutor(1, SoulThreadFactory.create(&quot;scheduled-upstream-task&quot;, false))
                .scheduleWithFixedDelay(this::scheduled,
                        30, Integer.parseInt(System.getProperty(&quot;soul.upstream.scheduledTime&quot;, &quot;30&quot;)), TimeUnit.SECONDS);
    }
}
</code></pre><p>UpstreamCacheManager 初始化时，若探活开关打开，则创建定时探活任务，此处默认 30 秒执行一次。</p><p>此处共涉及到两个配置参数：</p><ul><li>soul.upstream.check 探活开关：默认为 ture，设置为false表示不检测</li><li>soul.upstream.scheduledTime 探活时间间隔，默认10秒</li></ul><h4 id=3-2-探活任务>3.2 探活任务</h4><p>1）接下来看看探活任务实现（UpstreamCacheManager # scheduled）：</p><pre><code class=language-java>private void scheduled() {
    if (UPSTREAM_MAP.size() &gt; 0) {
        UPSTREAM_MAP.forEach((k, v) -&gt; {
            // 活动检查
            List&lt;DivideUpstream&gt; result = check(v);
            if (result.size() &gt; 0) {
                UPSTREAM_MAP_TEMP.put(k, result);
            } else {
                UPSTREAM_MAP_TEMP.remove(k);
            }
        });
    }
}
</code></pre><p>任务负责逐条遍历登记全量服务散列表，检查服务活性：</p><ul><li>若存活数大于0，则更新存活服务散列表</li><li>否则，移除存活服务散列表相应内容</li></ul><p>2）继续看服务列表活性检查处理（UpstreamCacheManager # check）：</p><pre><code class=language-java>private List&lt;DivideUpstream&gt; check(final List&lt;DivideUpstream&gt; upstreamList) {
    List&lt;DivideUpstream&gt; resultList = Lists.newArrayListWithCapacity(upstreamList.size());
    for (DivideUpstream divideUpstream : upstreamList) {
        // 检查服务活性
        final boolean pass = UpstreamCheckUtils.checkUrl(divideUpstream.getUpstreamUrl());
        if (pass) {
            // 更新服务状态
            if (!divideUpstream.isStatus()) {
                divideUpstream.setTimestamp(System.currentTimeMillis());
                divideUpstream.setStatus(true);
                ...
            }
            // 记录存活的服务
            resultList.add(divideUpstream);
        } else {
            // 更新服务状态
            divideUpstream.setStatus(false);
            ...
        }
    }
    return resultList;
}
</code></pre><p>负责遍历服务列表，根据 url 检查各服务活性并登记存活的服务。</p><h4 id=3-3-活性检查>3.3 活性检查</h4><p>1）服务活性检查实现（UpstreamCheckUtils # checkUrl）：</p><pre><code class=language-java>public static boolean checkUrl(final String url) {
    ...
    // 检查url是否为ip+端口格式
    if (checkIP(url)) {
        // 处理 ip 和端口
        String[] hostPort;
        if (url.startsWith(HTTP)) {
            final String[] http = StringUtils.split(url, &quot;\\/\\/&quot;);
            hostPort = StringUtils.split(http[1], Constants.COLONS);
        } else {
            hostPort = StringUtils.split(url, Constants.COLONS);
        }
        // 测试主机是否可连通
        return isHostConnector(hostPort[0], Integer.parseInt(hostPort[1]));
    } else {
        // 测试主机是否可达
        return isHostReachable(url);
    }
}
</code></pre><p>检查 url 是否为 ip + port 格式：</p><ul><li>若为 ip + 端口格式，则测试主机是否可连接</li><li>否则，测试主机是否可达</li></ul><p>2）测试主机是否可连接（UpstreamCheckUtils # isHostConnector）：</p><pre><code class=language-java>private static boolean isHostConnector(final String host, final int port) {
    try (Socket socket = new Socket()) {
        socket.connect(new InetSocketAddress(host, port));
    } catch (IOException e) {
        return false;
    }
    return true;
}
</code></pre><p>通过 socket 的 connection 测试 ip 的连通性。</p><p>3）测试主机是否可达（UpstreamCheckUtils # isHostReachable）：</p><pre><code class=language-java>private static boolean isHostReachable(final String host) {
    try {
        return InetAddress.getByName(host).isReachable(1000);
    } catch (IOException ignored) {
    }
    return false;
}
</code></pre><p>非 ip + 端口格式 url 尝试使用域名格式测试主机是否可达。</p><p>整体看下来，divide插件从缓存里拿到的服务器信息，来源于数据同步，由探活任务定期主动更新。</p><h2 id=负载均衡>负载均衡</h2><p>上面提到，divide 通过负载均衡算法挑选最终分发的服务 ip，看下负载均衡的实现（LoadBalanceUtils # selector）：</p><pre><code class=language-java>public static DivideUpstream selector(final List&lt;DivideUpstream&gt; upstreamList, final String algorithm, final String ip) {
    LoadBalance loadBalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getJoin(algorithm);
    return loadBalance.select(upstreamList, ip);
}
</code></pre><p>内部使用 ExtensionLoader 实现 SPI 机制，然后通过算法名加载对应的负载均衡算法，执行负载均衡计算最终分发到的服务 ip。</p><p>soul网关里默认支持三种负载均衡策略</p><ul><li>HASH(需要计算，可能存在不均衡的情况)</li><li>RANDOM(最简单最快，大量请求下几乎平均)</li><li>ROUND_ROBIN(需要记录状态，有一定的影响，大数据量下随机和轮询并无太大结果上的差异)</li></ul><p>默认为 RANDOM 随机算法，算法处理如下（RandomLoadBalance # doSelect）：</p><pre><code class=language-java>public DivideUpstream doSelect(final List&lt;DivideUpstream&gt; upstreamList, final String ip) {
    int totalWeight = calculateTotalWeight(upstreamList);
    boolean sameWeight = isAllUpStreamSameWeight(upstreamList);
    // 若权重不一致，则按总权重随机
    if (totalWeight &gt; 0 &amp;&amp; !sameWeight) {
        return random(totalWeight, upstreamList);
    }
    // 按服务数随机
    return random(upstreamList);
}
</code></pre><p>判断服务列表内服务的权重是否一致：</p><ul><li>若权重不一致，则按总权重随机</li><li>否则，按服务数随机</li></ul><p>按总权重随机细节（RandomLoadBalance # random）：</p><pre><code class=language-java>private DivideUpstream random(final int totalWeight, final List&lt;DivideUpstream&gt; upstreamList) {
    // 按总权重取随机数
    int offset = RANDOM.nextInt(totalWeight);
    // 确定随机值落在哪个段上
    for (DivideUpstream divideUpstream : upstreamList) {
        offset -= getWeight(divideUpstream);
        if (offset &lt; 0) {
            return divideUpstream;
        }
    }
    return upstreamList.get(0);
}
</code></pre><h2 id=总结>总结</h2><p>divide插件处理流程：</p><ul><li><p>获取可用服务列表</p><ul><li>服务列表最初来自 <code>soul-admin</code> 数据同步</li><li>可用服务列表默认每 30 秒主动探活更新</li></ul></li><li><p>负载均衡</p><ul><li>扩展加载器加载目标负载均衡算法</li><li>执行具体均衡策略</li><li>返回一个最终选择的服务信息</li></ul></li><li><p>设置最终服务的的url信息</p></li><li><p>交由插件链下游进行处理</p></li></ul></article><div class=-show-mobile><nav class=ss-pagination-next><a class=link-prev href=/zh/blog/soul_source_learning_18_ratelimiter/><span class=text>上一篇:</span>
<span class=text>Soul网关学习RateLimiter插件原理解析</span></a>
<a class=link-next href=/zh/blog/soul_source_learning_19_redirect/><span class=text>下一篇:</span>
<span class=text>Soul网关学习Redirect插件原理解析</span></a></nav></div></main><aside class=ss-layout-aside><div class=ss-card><h2 class=card-title>相关推荐</h2><ul class=ss-aside-related><li><a href=/zh/blog/soul_source_learning_18_ratelimiter/>Soul网关学习RateLimiter插件原理解析</a></li><li><a href=/zh/blog/soul_source_learning_11_spi/>Soul网关学习SPI学习使用</a></li><li><a href=/zh/blog/soul_source_learning_12_sign/>Soul网关学习Sign插件</a></li><li><a href=/zh/blog/soul_source_learning_09_httplongpolling_02/>Soul网关学习Http长轮询解析02</a></li><li><a href=/zh/blog/soul_source_learning_17_http/>Soul网关学习Http请求探险</a></li></ul></div><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/dromara/>Dromara</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/hmily/>hmily</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/soul/>Soul</a></li><li class=tag><a href=/zh/tags/tcc/>TCC</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/dromara>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/zh/community>社区</a>
<a class=link href=/zh/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=https://shenyu.apache.org/zh/projects/shenyu/overview/>Apache ShenYu</a>
<a class=link href=/zh/projects/hmily/overview/>Hmily</a>
<a class=link href=/zh/projects/raincat/overview/>Raincat</a>
<a class=link href=/zh/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>@dromara. org. All Rights Reserved</a></p></div></footer></body></html>