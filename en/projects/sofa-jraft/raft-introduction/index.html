<!doctype html><html><head><title>&#39;Introduction to the Raft algorithm&#39; · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="en"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/en/><img class=logo src=/img/logo.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/en/projects/><span>Projects</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/en/guides/><span>Guides</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/en/blog/><span>Blog</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/en/activities/><span>Activity</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/projects/sofa-jraft/raft-introduction/><span>中文</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/en/projects/>Projects</a>
<a class=navbar-item href=/en/guides/>Guides</a>
<a class=navbar-item href=/en/blog/>Blog</a>
<a class=navbar-item href=/en/activities/>Activity</a>
<a class=navbar-item href=/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=Search><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/projects/sofa-jraft/raft-introduction/>中</a></div></div></div></nav></header><div class=ss-layout-container><aside class="ss-layout-aside -left ss-card -soft-hidden"></aside><main class="ss-layout-main -card"><div class=ss-meta><div class=container><h1 class=title>&#39;Introduction to the Raft algorithm&#39;</h1><a class="edit-button -hidden-mobile" href=https://github.com/dromara/edit/master/content/en/projects/sofa-jraft/raft-introduction/index.md>Edit</a></div><div class=meta>Update time: 2021-01-24</div></div><article class=typo><h3 id=novel-features>Novel features:</h3><div class=bi-table><table><col width=nullpx><col width=nullpx><tbody><tr><td rowspan=1 colspan=1><div data-type=p>Strong leader</div></td><td rowspan=1 colspan=1><div data-type=p>Raft uses a stronger form of leadership than other consensus algorithms.</div><div data-type=p>For example, log entries only flow from the leader to other servers. This simplifies the management of replicated logs and makes Raft easier to understand.</div></td></tr><tr><td rowspan=1 colspan=1><div data-type=p>Leader election</div></td><td rowspan=1 colspan=1><div data-type=p>Raft uses randomized timers to elect leaders.</div><div data-type=p>This reduces election conflicts simply and rapidly.</div></td></tr><tr><td rowspan=1 colspan=1><div data-type=p>Membership change</div></td><td rowspan=1 colspan=1><div data-type=p>Raft uses a new joint consensus approach.</div></td></tr></tbody></table></div><h3 id=replicated-state-machines>Replicated state machines</h3><p><img src=https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*OiwGTZnO2uMAAAAAAAAAAABjARQnAQ alt="image.png | left | 321x179"></p><h4 id=1-replicated-state-machines-are-implemented-based-on-logs>1. Replicated state machines are implemented based on logs.</h4><ul><li>Each server stores a log.</li><li>Each log entry contains a command.</li><li>The state machine executes commands in order.</li></ul><h4 id=2-consensus-algorithms-for-practical-systems-typically-have-the-following-properties>2. Consensus algorithms for practical systems typically have the following properties:</h4><ul><li>They ensure safety.</li><li>They are highly available.</li><li>They do not depend on the time sequence to ensure log consistency.</li><li>A command can be completed as soon as a majority of the cluster has responded to a single round of remote procedure calls (RPCs).</li></ul><h3 id=drawbacks-of-paxos>Drawbacks of Paxos</h3><ul><li>Paxos is exceptionally difficult to understand.</li><li>Paxos does not provide a good foundation for building practical implementations.</li></ul><h3 id=raft-design-principles>Raft design principles</h3><ul><li>Concept decomposition<ul><li>Leader election</li><li>Log replication</li><li>Membership changes</li></ul></li><li>Raft reduces the number of states to simplify the state space.<ul><li>Raft does not allow log holes and restricts the possibilities of log inconsistency.</li><li>Raft uses randomized timers to simplify the leader election.</li></ul></li></ul><h3 id=raft-consistency-algorithm>Raft consistency algorithm</h3><h4 id=state><strong>State</strong></h4><hr><p><strong>Persistent state on all servers (updated on stable storage before responding to RPCs):</strong></p><table><thead><tr><th align=left>currentTerm</th><th align=left>The latest term that the server gets (initialized to 0 on initial boot, increasing monotonically)</th></tr></thead><tbody><tr><td align=left>votedFor</td><td align=left>The candidateId that has received votes in the current term (or null if none).</td></tr><tr><td align=left>Log[]</td><td align=left>Log entries. Each entry contains a command for the state machine, and the term when the entry was received by the leader.</td></tr></tbody></table><p><strong>Volatile state on all servers:</strong></p><table><thead><tr><th align=left>commitIndex</th><th align=left>The index of the highest log entry known to be committed.</th></tr></thead><tbody><tr><td align=left>lastApplied</td><td align=left>The index of the highest log entry applied to the state machine.</td></tr></tbody></table><p><strong>Volatile state on leaders:</strong></p><table><thead><tr><th align=left>nextIndex[]</th><th align=left>The index of the next log entry to be sent to each follower.</th></tr></thead><tbody><tr><td align=left>matchIndex[]</td><td align=left>The index of the highest log entry known to have been replicated on each follower.</td></tr></tbody></table><h4 id=appendentries-rpc-log-replication>AppendEntries RPC (log replication)</h4><p>Called by the leader to replicate log entries or used as heartbeats.</p><hr><p><strong>Arguments:</strong></p><table><thead><tr><th align=left>term</th><th align=left>leader&rsquo;s term</th></tr></thead><tbody><tr><td align=left>leaderId</td><td align=left>The leader&rsquo;s ID that can be used to redirect clients to the leader.</td></tr><tr><td align=left>prevLogIndex</td><td align=left>The index of the preceding log entry.</td></tr><tr><td align=left>prevLogTerm</td><td align=left>The term of the prevLogIndex entry.</td></tr><tr><td align=left>entries[]</td><td align=left>The log entries to be stored (empty for heartbeat, and the leader may send more than one for efficiency).</td></tr><tr><td align=left>leaderCommit</td><td align=left>The leader&rsquo;s commitIndex (for committed log entries).</td></tr></tbody></table><p><strong>Results:</strong></p><table><thead><tr><th align=left>term</th><th align=left>The currentTerm for the leader to update.</th></tr></thead><tbody><tr><td align=left>success</td><td align=left>True if the follower contains log entries matching prevLogIndex and prevLogTerm.</td></tr></tbody></table><p><strong>Receiver implementation:</strong></p><ol><li>Reject the log entry and return false if term &lt; currentTerm.</li><li>Reject the log entry and return false if the log does not contain an entry at prevLogIndex whose term matches prevLogTerm.</li><li>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.</li><li>Append any new entries that do not exist in the log.</li><li>If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry).</li></ol><h4 id=requestvote-rpc-request-for-votes>RequestVote RPC (request for votes)</h4><hr><p><strong>Arguments</strong></p><table><thead><tr><th align=left>term</th><th align=left>The candidate&rsquo;s term.</th></tr></thead><tbody><tr><td align=left>candidateId</td><td align=left>The candidate initiating a vote request.</td></tr><tr><td align=left>lastLogIndex</td><td align=left>The index of the candidate&rsquo;s last log entry.</td></tr><tr><td align=left>lastLogTerm</td><td align=left>The term of the candidate&rsquo;s last log entry.</td></tr></tbody></table><p><strong>Results:</strong></p><table><thead><tr><th align=left>term</th><th align=left>The currentTerm for the candidate to update.</th></tr></thead><tbody><tr><td align=left>voteGranted</td><td align=left>True means the candidate has received votes.</td></tr></tbody></table><p><strong>Receiver implementation:</strong></p><ol><li>Reject the vote and return false if term &lt; currentTerm.</li><li>If votedFor is null or candidateId, and the candidate&rsquo;s log is at least as up-to-date as the receiver&rsquo;s log, the receiver grants a vote to the candidate, and returns true.</li></ol><h4 id=rules-for-servers><strong>Rules for servers</strong></h4><ul><li><strong>All Servers:</strong><ul><li>If commitIndex &gt; lastApplied, increment lastApplied, and apply log[lastApplied] to state machine.</li><li>If the RPC request or response contains term T &gt; currentTerm, set currentTerm to T and transit into a follower.</li></ul></li><li><strong>Follower</strong><ul><li>Responds to RPCs from candidates and the leader.</li><li>If the election timeout elapses, and the follower fails to receive any AppendEntries RPCs from the current leader or any RequestVote RPCs from any candidate, the follower transits into a candidate.</li></ul></li><li><strong>Candidate</strong><ul><li>Starts election after transiting into a candidate:<ul><li>Increment currentTerm &gt; Reset the election timer &gt; Vote for itself &gt; Send RequestVote RPCs to all other servers.</li></ul></li><li>If the candidate receives votes from a majority of servers, it becomes the leader.</li><li>If a candidate receives an AppendEntries RPC from the new leader, it transits into a follower.</li><li>If the election timeout elapses, it starts a new election.</li></ul></li><li><strong>Leader</strong><ul><li>Upon election, the leader sends empty AppendEntries RPCs (heartbeat) to each server, and repeats the step during idle periods to prevent the election from timeing out.</li><li>If the leader receives a command from a client, it appends an entry to the local log and sends AppendEntries RPCs to all servers. After receiving responses from a majority of the servers, it applies the entry to the state machine and replies responses to the clients.</li><li>If last log index &gt;= nextIndex for a follower, the leader sends an AppendEntries RPC with log entries starting from the nextIndex. If it is successful, the leader updates the follower&rsquo;s nextIndex and matcheIndex. If AppendEntries fails because of log inconsistency, the leader decrements the nextIndex and resends the AppendEntries RPC to the follower.</li><li>If there is an N that N &gt; commitIndex, a majority of matchIndex[i] &gt;= N, and log]N[.term == currentTerm, the leader sets commitIndex to N.</li></ul></li></ul><h4 id=summary-of-the-raft-consensus-algorithm>Summary of the Raft consensus algorithm</h4><table><thead><tr><th align=left>Election safety</th><th align=left>At most one leader can be elected in a given term.</th></tr></thead><tbody><tr><td align=left>Leader append-only</td><td align=left>A leader never overwrites or deletes entries in its log. It only appends new entries.</td></tr><tr><td align=left>Log matching</td><td align=left>If two logs contain an entry with the same index and term, then the logs are identical in all entries up through the given index.</td></tr><tr><td align=left>Leader completeness</td><td align=left>If a log entry is committed in a given term, that entry will be presented in the logs of the leaders for all higher-numbered terms.</td></tr><tr><td align=left>State machine safety</td><td align=left>If a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index.</td></tr></tbody></table><h3 id=rpc-communication-in-raft>RPC communication in Raft</h3><ul><li>RequestVote RPC</li><li>AppendEntries RPC<ul><li>Log entries</li><li>Heartbeat</li></ul></li><li>InstallSnapshot RPC</li></ul><h3 id=roles-and-states-transition>Roles and states transition</h3><p><img src=https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*eTJ3SZlSpsIAAAAAAAAAAABjARQnAQ alt="image.png | left | 352x137"></p><ul><li>Follower: All followers are passive. They issue no requests on their own but simply respond to requests from the leader and candidates.</li><li>Leader: The leader handles all client requests. If a client contacts a follower, the follower redirects the client to the leader.</li><li>Candidate: A candidate can be elected as a new leader.</li></ul><h3 id=terms-logical-clock>Terms (logical clock)</h3><p><img src=https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*iKWRRabaMNEAAAAAAAAAAABjARQnAQ alt="image.png | left | 327x119"></p><p>Raft divides time into terms of arbitrary length. Each term begins with an election. If a candidate wins the election, it becomes the leader and manages the cluster within the term. In the case of a split vote, the term will end with no leader. Different servers may observe the transitions between terms at different time.</p><h3 id=leader-election>Leader election</h3><ul><li>Follower &gt; candidate (triggered by election timeout)<ul><li>Candidate &gt; leader<ul><li>The candidate wins the election.</li></ul></li><li>Candidate &gt; follower<ul><li>Another server wins the election.</li></ul></li><li>Candidate &gt; candidate<ul><li>No server wins the election within the specified period.</li></ul></li></ul></li></ul><h3 id=prevention-of-multiple-candidates-starting-leader-election-simultaneously>Prevention of multiple candidates starting leader election simultaneously</h3><p>Randomized election timeouts</p><h3 id=log-replication>Log replication</h3><p><img src=https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*Bn5lR6TAWEwAAAAAAAAAAABjARQnAQ alt="image.png | left | 318x233"></p><p>Once a leader has been elected, it begins receiving client requests. Each client request contains a command to be executed by the replicated state machines. The leader appends the command to its log as a new entry, and then issues AppendEntries RPCs in parallel to each of the other servers to replicate the entry. When the entry has been safely replicated, the leader applies the entry to its state machine and returns the result of that execution to the client. If followers crash or run slowly, or if network packets are lost, the leader retries AppendEntries RPCs indefinitely (even if it has responded to the client) until all followers eventually store all log entries.</p><p><strong>Features of the Raft log mechanism</strong></p><ul><li>If two entries in different logs share the same index and term, they store the same command.<ul><li>A leader creates at most one entry with a given log index in a given term, and log entries never change their position in the log.</li></ul></li><li>If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.<ul><li>This is guaranteed by a simple consistency check performed by AppendEntries RPCs. When sending an AppendEntries RPC, the leader includes the index and term of the entry in its log. If the follower does not find an entry in its log with the same index and term, it refuses the new entries, and the consistency check acts as an induction step.</li></ul></li><li>The leader handles inconsistencies by forcing the followers&rsquo; logs to duplicate its own.<ul><li>To bring a follower&rsquo;s log into consistency with its own, the leader must find the latest log entry where the two logs agree, delete any entries in the follower&rsquo;s log after that point, and send the follower all of the leader&rsquo;s entries after that point. All of these actions happen in response to the consistency check performed by AppendEntries RPCs.</li><li>The leader maintains a nextIndex for each follower, which is the index of the next log entry the leader will send to that follower. When a leader first comes to power, it initializes all nextIndex values to the index just after the last one in its log. If a follower&rsquo;s log is inconsistent with the leader&rsquo;s, the AppendEntries consistency check will fail in the next AppendEntries RPC. After a rejection, the leader decrements nextIndex and retries the AppendEntries RPC. Eventually nextIndex will reach a point where the leader and follower logs match. When this happens, AppendEntries will succeed, which removes any conflicting entries in the follower&rsquo;s log and appends entries from the leader&rsquo;s log (if any). Then the follower&rsquo;s log is consistent with the leader&rsquo;s.</li></ul></li></ul><h3 id=safety>Safety</h3><ul><li>Election restriction<ul><li>Raft uses a restriction on which servers may be elected the leader, which ensures servers with incomplete log entries do not win elections.<ul><li>RequestVote RPC restriction: The RPC includes information about the candidate&rsquo;s log, and the voter denies its vote if its own log is more up-to-date than that of the candidate.</li></ul></li><li>A leader never overwrites entries in its log.</li><li>Log entries only flow from the leader to followers.</li></ul></li><li>Submit entries from previous terms<ul><li>Log entries maintain the same term number over time and across logs.</li></ul></li><li>Safety argument<ul><li>Leader completeness<ul><li>If a log entry is committed in a given term, then that entry will be presented in the logs of the leaders for all higher-numbered terms.</li></ul></li><li>State machine safety<ul><li>If a server has applied a log entry at a given index to its state machine, no other server will apply a different log entry for the same index.</li></ul></li></ul></li></ul><h3 id=follower-and-candidate-crashes>Follower and candidate crashes</h3><ul><li>Raft handles these failures by retrying indefinitely.</li><li>Raft RPCs are idempotent.</li></ul><h3 id=timing-and-availability>Timing and availability</h3><p><strong>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</strong></p><table><thead><tr><th align=left>broadcastTime</th><th align=left>The average time it takes a server to send RPCs in parallel to every server in the cluster and receive their responses.</th></tr></thead><tbody><tr><td align=left>electionTimeout</td><td align=left>The period of time that followers would wait for communication from the leader before they start an election.</td></tr><tr><td align=left>MTBF</td><td align=left>The average time between failures for a single server.</td></tr></tbody></table><ul><li>The broadcast time should be smaller than the election timeout period by a magnitude so that leaders can reliably send the heartbeat messages to keep followers from starting elections. Given the randomized approach used for election timeouts, this inequality also makes split votes unlikely.</li><li>The election timeout should be smaller than MTBF by a magnitude so that the system can run steadily. When the leader crashes, the system will be unavailable for roughly the election timeout period.</li></ul><h3 id=cluster-membership-changes>Cluster membership changes</h3><p>In the example shown in the following figure, the cluster grows from three servers to five. Directly doing so may cause the cluster to split into two independent majorities: an old group that consists of Server 1 and 2, and a new group that consists of Server 3, 4, and 5. They may cause conflicts in decisions.</p><p><img src=https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*YFTGRbfg8XIAAAAAAAAAAABjARQnAQ alt="image.png | left | 392x232"></p><p><strong>A two-phase approach</strong></p><p><img src=https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*wcVDTo4CfrwAAAAAAAAAAABjARQnAQ alt="image.png | left | 354x165"></p><p>Raft uses a joint consensus approach to make node changes safe. The cluster first switches to a transitional configuration which combines both the old and new configurations and is called joint consensus. The current leader stores the configuration for joint consensus (Cold and Cnew in the figure) as a log entry and replicates it to other nodes. Once this log entry has been committed, the system then transitions to the new configuration. The specific steps are as follows:</p><ol><li>The current leader first replicates data to new nodes so that they can catch up.</li><li>After all new nodes have caught up with the rest of the cluster, the leader replicates the Cold,new log entry to both the old and new nodes.</li><li>When the majorities of the old and new nodes respond to Cold,new, the cluster switches to the Cold,new configuration. Then the leader replicates the log entry for the Cnew configuration to new nodes.</li><li>When the majority of the new nodes respond to Cnew, the cluster switches to the new configuration.</li></ol><h3 id=log-compaction>Log compaction</h3><p><img src=https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*77gySo2CTewAAAAAAAAAAABjARQnAQ alt="image.png | left | 396x242"></p><ul><li>Each server takes snapshots independently, covering only committed entries in its log.</li><li>A snapshot mainly covers:<ul><li>The state machine state.</li><li>A small amount of metadata of the Raft group (as shown in the above figure). Such metadata is preserved to support the AppendEntries consistency check for the first log entry following the snapshot.</li><li>To enable cluster membership changes, the snapshot also includes the latest configuration in the log as of the last included index.</li></ul></li></ul><p><strong>InstallSnapshot RPC</strong></p><ul><li>Although servers normally take snapshots independently, the leader must occasionally send snapshots to followers that lag behind. This happens when the leader has already discarded the next log entry that it needs to send to a follower.</li></ul><table><thead><tr><th align=left>term</th><th align=left>The leader&rsquo;s term.</th></tr></thead><tbody><tr><td align=left>leaderId</td><td align=left>The leader&rsquo;s ID that can be used to redirect clients to the leader.</td></tr><tr><td align=left>lastIncludedIndex</td><td align=left>Index of the last log entry in the snapshot.</td></tr><tr><td align=left>lastIncludedTerm</td><td align=left>The term of lastIncludedIndex.</td></tr><tr><td align=left>offset</td><td align=left>The byte offset where the chunk is positioned in the snapshot file.</td></tr><tr><td align=left>data[]</td><td align=left>The raw bytes of the snapshot chunk, starting from the offset.</td></tr><tr><td align=left>done</td><td align=left>True if this is the last chunk.</td></tr></tbody></table><p><strong>Receiver implementation:</strong></p><ul><li>Reply immediately if term &lt; currentTerm.</li><li>Create a new snapshot file if it is the first chunk (offset is 0).</li><li>Write data into the snapshot file at a given offset.</li><li>Reply and wait for more data chunks if done is false.</li><li>Save the snapshot file, discard any existing or partial snapshot with a smaller index.</li><li>If existing log entry has the same index and term as snapshot&rsquo;s last included entry, retain log entries following it and reply.</li><li>Discard the entire log.</li><li>Reset the state machine using snapshot contents (and load snapshot&rsquo;s cluster configuration).</li></ul><h3 id=client-interaction>Client interaction</h3><ul><li>Clients of Raft send all of their requests to the leader.</li><li>Linearizable reads<ul><li>Write the Raft log and use the state machine.</li><li>The leader sends heartbeats to all nodes and receives responses from more than half of them to ensure it is still the leader. Then it can provide linearizable read.</li><li>The leader could also rely on the heartbeat mechanism to provide a form of lease (lease read), but this would rely on the accuracy of the local clock.</li></ul></li></ul><h3 id=references>References</h3><p><a href=https://github.com/brpc/braft/blob/master/docs/cn/raft_protocol.md>Braft document</a></p><p><a href=https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf>The Raft paper</a></p></article></main></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>Resources</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/shuaiqiyu>Gitee</a></div><div class=cate><h2 class=cate-title>Get Involved</h2><a class=link href=https://github.com/dromara/soul/issues/new>Feedback</a>
<a class=link href=/community>Community</a>
<a class=link href=/blog>Blog</a></div><div class=cate><h2 class=cate-title>Document</h2><a class=link href=/projects/soul/overview/>Soul</a>
<a class=link href=/projects/hmily/overview/>Hmily</a>
<a class=link href=/projects/raincat/overview/>Raincat</a>
<a class=link href=/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>Wechat Official Account</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ Group</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>