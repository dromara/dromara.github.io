<!doctype html><html><head><title>Ark 服务通信 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/><img class=logo src=/img/logo.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/guides/><span>指南</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/>项目</a>
<a class=navbar-item href=/guides/>指南</a>
<a class=navbar-item href=/blog/>博客</a>
<a class=navbar-item href=/activities/>活动</a>
<a class=navbar-item href=/community/>社区</a>
<a class=navbar-item href=/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item></div></div></div></nav></header><div class=ss-layout-container><aside class="ss-layout-aside -left ss-card -soft-hidden"></aside><main class="ss-layout-main -card"><div class=ss-meta><div class=container><h1 class=title>Ark 服务通信</h1><a class="edit-button -hidden-mobile" href=https://github.com/dromara/edit/master/content/zh/projects/sofa-boot/sofa-ark-ark-jvm/index.md>编辑</a></div><div class=meta>更新时间: 2021-01-24</div></div><article class=typo><p>在 <a href=../sofa-ark-ark-service>Ark 服务机制</a> 中，我们详细介绍了如何引用和发布插件服务，主要是解决 Plugin 和 Biz 的通信问题；为了解决 Biz 之间的通信问题，SOFAArk 引入了 SOFABoot 提供的 <code>SofaService/SofaReference</code> 编程界面；下面介绍其使用方法。</p><h3 id=引入依赖>引入依赖</h3><p>引入 runtime-sofa-boot-plugin 依赖，如果应用基于 Spring Boot 1.x 开发，推荐使用 v2.6.1 版本；如果应用基于 Spring Boot 2.x 开发，推荐使用 v3.1.3 版本；</p><pre><code class=language-xml>&lt;dependency&gt;
    &lt;groupId&gt;com.alipay.sofa&lt;/groupId&gt;
    &lt;artifactId&gt;runtime-sofa-boot-plugin&lt;/artifactId&gt;
    &lt;version&gt;${sofa.boot.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id=发布和引用-jvm-服务>发布和引用 JVM 服务</h3><p>SOFAArk 引入了 SOFABoot 提供的 <code>SofaService/SofaReference</code> JVM 服务概念(<a href=../module-service>参考文档</a>)，为了方便文档统一，重复其介绍。</p><p>SOFABoot 提供三种方式给开发人员发布和引用 JVM 服务</p><ul><li>XML 方式</li><li>Annotation 方式</li><li>编程 API 方式</li></ul><h3 id=xml-方式>XML 方式</h3><h4 id=服务发布>服务发布</h4><p>首先需要定义一个 Bean：</p><pre><code class=language-xml>&lt;bean id=&quot;sampleService&quot; class=&quot;com.alipay.sofa.runtime.test.service.SampleServiceImpl&quot;&gt;
</code></pre><p>然后通过 SOFA 提供的 Spring 扩展标签来将上面的 Bean 发布成一个 SOFA JVM 服务。</p><pre><code class=language-xml>&lt;sofa:service interface=&quot;com.alipay.sofa.runtime.test.service.SampleService&quot; ref=&quot;sampleService&quot;&gt;
    &lt;sofa:binding.jvm/&gt;
&lt;/sofa:service&gt;
</code></pre><p>上面的配置中的 interface 指的是需要发布成服务的接口，ref 指向的是需要发布成 JVM 服务的 Bean，至此，我们就已经完成了一个 JVM 服务的发布。</p><h4 id=服务引用>服务引用</h4><p>使用 SOFA 提供的 Spring 扩展标签引用服务:</p><pre><code class=language-xml>&lt;sofa:reference interface=&quot;com.alipay.sofa.runtime.test.service.SampleService&quot; id=&quot;sampleServiceRef&quot;&gt;
    &lt;sofa:binding.jvm/&gt;
&lt;/sofa:service&gt;
</code></pre><p>上面的配置中的 interface 是服务的接口，需要和发布服务时配置的 interface 一致。id 属性的含义同 Spring BeanId。上面的配置会生成一个 id 为 sampleServiceRef 的 Spring Bean，你可以将 sampleServiceRef 这个 Bean 注入到当前 SOFABoot 模块 Spring 上下文的任意地方。</p><blockquote><p>service/reference 标签还支持 RPC 服务发布，相关文档: <a href=https://github.com/sofastack/sofa-rpc/wiki/Publish-And-Reference>RPC 服务发布与引用</a></p></blockquote><h3 id=annotation-方式>Annotation 方式</h3><blockquote><p><strong>警告</strong></p><p>如果一个服务已经被加上了 @SofaService 的注解，它就不能再用 XML 的方式去发布服务了，选择一种方式发布服务，而不是两种混用。</p></blockquote><p>除了通过 XML 方式发布 JVM 服务和引用之外，SOFABoot 还提供了 Annotation 的方式来发布和引用 JVM 服务。通过 Annotation 方式发布 JVM 服务，只需要在实现类上加一个 @SofaService 注解即可，如下：</p><pre><code class=language-java>@SofaService
public class SampleImpl implements SampleInterface {
   public void test() {

   }
}
</code></pre><blockquote><p><strong>提示</strong></p><p>@SofaService 的作用是将一个 Bean 发布成一个 JVM 服务，这意味着虽然你可以不用再写 &lt;sofa:service/&gt; 的配置，但是还是需要事先将 @SofaService 所注解的类配置成一个 Spring Bean。</p></blockquote><p>在使用 XML 配置 &lt;sofa:service/&gt; 的时候，我们配置了一个 interface 属性，但是在使用 @SofaService 注解的时候，却没有看到有配置服务接口的地方。这是因为当被 @SofaService 注解的类只有一个接口的时候，框架会直接采用这个接口作为服务的接口。当被 @SofaService 注解的类实现了多个接口时，可以设置 @SofaService 的 interfaceType 字段来指定服务接口，比如下面这样：</p><pre><code class=language-java>@SofaService(interfaceType=SampleInterface.class)
public class SampleImpl implements SampleInterface, Serializable {
   public void test() {

   }
}
</code></pre><p>和 @SofaService 对应，Sofa 提供了 @SofaReference 来引用一个 JVM 服务。假设我们需要在一个 Spring Bean 中使用 SampleJvmService 这个 JVM 服务，那么只需要在字段上加上一个 @SofaReference 的注解即可：</p><pre><code class=language-java>public class SampleServiceRef {
    @SofaReference
    private SampleService sampleService;
}
</code></pre><p>和 @SofaService 类似，我们也没有在 @SofaReference 上指定服务接口，这是因为 @SofaReference 在不指定服务接口的时候，会采用被注解字段的类型作为服务接口，你也可以通过设定 @SofaReference 的 interfaceType 属性来指定：</p><pre><code class=language-java>public class SampleServiceRef {
    @SofaReference(interfaceType=SampleService.class)
    private SampleService sampleService;
}
</code></pre><p>使用 @SofaService 注解发布服务时，需要在实现类上打上 @SofaService 注解；在 Spring Boot 使用 Bean Method 创建 Bean 时，会导致 @Bean 和 @SofaService 分散在两处，而且无法对同一个实现类使用不同的 unique id。因此自 SOFABoot v2.6.0 及 v3.1.0 版本起，支持 @SofaService 作用在 Bean Method 之上，例如：</p><pre><code class=language-java>@Configuration
public class SampleSofaServiceConfiguration {
    @Bean(&quot;sampleSofaService&quot;)
    @SofaService(uniqueId = &quot;service1&quot;)
    SampleService service() {
        return new SampleServiceImpl(&quot;&quot;);
    }
}
</code></pre><p>同样为了方便在 Spring Boot Bean Method 使用注解 @SofaReference 引用服务，自 SOFABoot v2.6.0 及 v3.1.0 版本起，支持在 Bean Method 参数上使用 @SofaReference 注解引用 JVM 服务，例如：</p><pre><code class=language-java>@Configuration
public class MultiSofaReferenceConfiguration {
    @Bean(&quot;sampleReference&quot;)
    TestService service(@Value(&quot;$spring.application.name&quot;) String appName,
                        @SofaReference(uniqueId = &quot;service&quot;) SampleService service) {
        return new TestService(service);
    }
}
</code></pre><h3 id=编程-api-方式>编程 API 方式</h3><p>SOFABoot 为 JVM 服务的发布和引用提供了一套编程 API 方式，方便直接在代码中发布和引用 JVM 服务，与 Spring 的 ApplicationContextAware 类似，为使用编程 API 方式，首先需要实现 ClientFactoryAware 接口获取编程组件 API：</p><pre><code class=language-java>public class ClientFactoryBean implements ClientFactoryAware {
    private ClientFactory clientFactory;

    @Override
    public void setClientFactory(ClientFactory clientFactory) {
        this.clientFactory = clientFactory;
    }
}
</code></pre><p>以 SampleService 为例，看下如何使用 clientFactory 通过编程 API 方式发布 JVM 服务：</p><pre><code class=language-java>ServiceClient serviceClient = clientFactory.getClient(ServiceClient.class);

ServiceParam serviceParam = new ServiceParam();
serviceParam.setInstance(new SampleServiceImpl());
serviceParam.setInterfaceType(SampleService.class);
serviceClient.service(serviceParam);
</code></pre><p>上面的代码中</p><ol><li>首先通过 clientFactory 获得 ServiceClient 对象</li><li>然后构造 ServiceParam 对象，ServiceParam 对象包含发布服务所需参数，通过 setInstance 方法来设置需要被发布成 JVM 服务的对象，setInterfaceType 来设置服务的接口</li><li>最后，调用 ServiceClient 的 service 方法，发布一个 JVM 服务</li></ol><p>通过编程 API 方式引用 JVM 服务的代码也是类似的：</p><pre><code class=language-java>ReferenceClient referenceClient = clientFactory.getClient(ReferenceClient.class);

ReferenceParam&lt;SampleService&gt; referenceParam = new ReferenceParam&lt;SampleService&gt;();
referenceParam.setInterfaceType(SampleService.class);
SampleService proxy = referenceClient.reference(referenceParam);
</code></pre><p>同样，引用一个 JVM 服务只需从 ClientFactory 中获取一个 ReferenceClient ，然后和发布一个服务类似，构造出一个 ReferenceParam，然后设置好服务的接口，最后调用 ReferenceClient 的 reference 方法即可。</p><blockquote><p><strong>提示</strong></p><p>通过动态客户端创建的 Reference 对象是一个非常重的对象，请大家在使用的时候不要频繁创建，自行做好缓存，否则可能存在内存溢出的风险。</p></blockquote><p>除了实现 ClientFactoryAware 接口用于获取 ServiceClient 和 ReferenceClient 对象，还可以使用简便的注解 <code>@SofaClientFactory</code> 获取编程 API，例如</p><pre><code class=language-java>public class ClientBean {
    @SofaClientFactory
    private ReferenceClient referenceClient;
    
    @SofaClientFactory
    private ServiceClient serviceClient;
}
</code></pre><h3 id=uniqueid>uniqueId</h3><p>有些时候，针对一个接口，我们会需要发布两个服务出来，分别对应到不同的实现。继续前面的 sampleService 的例子，我们可能有两个 SampleService 的实现，这两个实现我们都需要发布成 SOFA 的 JVM Service，按照前面的教程，采用 XML 的方式，我们就可能用下面这种方式进行配置：</p><pre><code class=language-xml>&lt;sofa:service interface=&quot;com.alipay.sofa.runtime.test.service.SampleService&quot; ref=&quot;sampleService1&quot;&gt;
&lt;/sofa:service&gt;
&lt;sofa:service interface=&quot;com.alipay.sofa.runtime.test.service.SampleService&quot; ref=&quot;sampleService2&quot;&gt;
&lt;/sofa:service&gt;
</code></pre><p>上面的服务发布没有什么问题，但是当需要引用服务的时候，就出现了问题了，例如我们使用以下配置：</p><pre><code class=language-xml>&lt;sofa:reference interface=&quot;com.alipay.sofa.runtime.test.service.SampleService&quot; id=&quot;sampleService&quot;&gt;
&lt;/sofa:reference&gt;
</code></pre><p>这个 JVM 引用到底引用的是哪个 JVM 服务呢，我们无从知晓。</p><p>为了解决上面的这种问题，SOFABoot 引入了 uniqueId 的概念，针对服务接口一样的 JVM 服务，可以通过 uniqueId 来进行区分，上面的服务发布的代码我们加入 uniqueId 后，我们可以改成下面这样：</p><pre><code class=language-xml>&lt;sofa:service interface=&quot;com.alipay.sofa.runtime.test.service.SampleService&quot; ref=&quot;sampleService1&quot; unique-id=&quot;ss1&quot;&gt;
&lt;/sofa:service&gt;
&lt;sofa:service interface=&quot;com.alipay.sofa.runtime.test.service.SampleService&quot; ref=&quot;sampleService2&quot; unique-id=&quot;ss2&quot;&gt;
&lt;/sofa:service&gt;
</code></pre><p>然后，在引用服务的时候，如果我们要使用 sampleService1 的服务，可以指定 unique-id 为 ss1，比如：</p><pre><code class=language-xml>&lt;sofa:reference interface=&quot;com.alipay.sofa.runtime.test.service.SampleService&quot; id=&quot;sampleService&quot; unique-id=&quot;ss1&quot;&gt;
&lt;/sofa:reference&gt;
</code></pre><p>如果要使用 sampleService2 的服务，可以指定 unique-id 为 ss2，比如：</p><pre><code class=language-xml>&lt;sofa:reference interface=&quot;com.alipay.sofa.runtime.test.service.SampleService&quot; id=&quot;sampleService&quot; unique-id=&quot;ss2&quot;&gt;
&lt;/sofa:reference&gt;
</code></pre><p>上面说的是在 XML 的方式中使用 uniqueId。当你用 Annotation 的方式发布 JVM 服务和引用的时候，可以通过设置 @SofaService 和 @SofaReference 的 uniqueId 属性来设置 uniqueId。当你用编程 API 的方式发布或者引用 JVM 服务的时候，可以通过 ServiceParam 和 ReferenceParam 的 setUniqueId 方法来设置 uniqueId。</p><h3 id=跳过序列化>跳过序列化</h3><p>在 Biz 之间使用 JVM 服务调用时，因为每个 Biz 有单独的类加载器加载，因此每次 JVM 调用都会走 Hessian 序列化协议；为了性能的提升，有时不希望走序列化，而是走直接调用的方式，此时需要做两步额外的工作，以下面接口服务为例：</p><pre><code class=language-java>public interface SampleService {
    Result service();
}
</code></pre><ul><li>打包插件</li></ul><p>因为走直接调用的方式，因此接口类 SampleService 及其依赖（比如参数，返回值）等都需要下沉为 Ark Plugin ，并在插件配置中将这些类导出，这样做的目的是多个 Biz 中使用接口时，该接口类统一委托给 Plugin 加载，否则报错如下：</p><pre><code class=language-text>java.lang.IllegalArgumentException: object is not an instance of declaring class
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at com.alipay.sofa.runtime.integration.invoke.DynamicJvmServiceProxyFinder$DynamicJvmServiceInvoker.doInvoke(DynamicJvmServiceProxyFinder.java:164)
    at com.alipay.sofa.runtime.spi.service.ServiceProxy.invoke(ServiceProxy.java:39)
    at com.alipay.sofa.runtime.service.binding.JvmBindingAdapter$JvmServiceInvoker.doInvoke(JvmBindingAdapter.java:171)
    at com.alipay.sofa.runtime.spi.service.ServiceProxy.invoke(ServiceProxy.java:39)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212)
    at com.sun.proxy.$Proxy73.service(Unknown Source)
    at com.alipay.sofa.demo.service.SampleRestService.sampleService(SampleRestService.java:87)
</code></pre><ul><li>发布服务指定跳过序列化</li></ul><p>默认情况下，通过注解或者xml发布 JVM 服务，在跨 Biz 调用时，都会走序列化，如果想跳过，需要在发布服务时，指定 <code>serialize = false</code></p><p>1、注解指定</p><pre><code class=language-java>@SofaService(bindings = {@SofaServiceBinding(serialize = false)})
</code></pre><p>2、xml 指定</p><pre><code class=language-xml>&lt;sofa:binding.jvm serialize=&quot;true&quot;/&gt;
</code></pre></article></main></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/shuaiqiyu>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/community>社区</a>
<a class=link href=/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/projects/soul/overview/>Soul</a>
<a class=link href=/projects/hmily/overview/>Hmily</a>
<a class=link href=/projects/raincat/overview/>Raincat</a>
<a class=link href=/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>