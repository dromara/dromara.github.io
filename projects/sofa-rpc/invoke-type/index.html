<!doctype html><html><head><title>Bolt 协议调用方式 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/><img class=logo src=/img/logo.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/guides/><span>指南</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/en/projects/sofa-rpc/invoke-type/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/>项目</a>
<a class=navbar-item href=/guides/>指南</a>
<a class=navbar-item href=/blog/>博客</a>
<a class=navbar-item href=/activities/>活动</a>
<a class=navbar-item href=/community/>社区</a>
<a class=navbar-item href=/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/en/projects/sofa-rpc/invoke-type/>En</a></div></div></div></nav></header><div class=ss-layout-container><aside class="ss-layout-aside -left ss-card -soft-hidden"></aside><main class="ss-layout-main -card"><div class=ss-meta><div class=container><h1 class=title>Bolt 协议调用方式</h1><a class="edit-button -hidden-mobile" href=https://github.com/dromara/edit/master/content/zh/projects/sofa-rpc/invoke-type/index.md>编辑</a></div><div class=meta>更新时间: 2021-01-24</div></div><article class=typo><h2 id=调用方式>调用方式</h2><p>SOFARPC 在 Bolt 协议下提供了多种调用方式满足不同的场景。</p><h3 id=同步>同步</h3><p>在同步的调用方式下，客户端发起调用后会等待服务端返回结果再进行后续的操作。这是 SOFARPC 的默认调用方式，无需进行任何设置即可。</p><h3 id=异步>异步</h3><p>异步调用的方式下，客户端发起调用后不会等到服务端的结果，继续执行后面的业务逻辑。服务端返回的结果会被 SOFARPC 缓存，当客户端需要结果的时候，再主动调用 API 获取。如果需要将一个服务设置为异步的调用方式，在对应的使用方式下设置 <code>type</code> 属性即可：</p><h4 id=xml-方式>XML 方式</h4><p>在 XML 方式下，设置 <code>&lt;sofa:global-attrs&gt;</code> 标签的 <code>type</code> 属性为 <code>future</code> 即可：</p><pre><code class=language-xml>&lt;sofa:reference interface=&quot;com.example.demo.SampleService&quot; id=&quot;sampleService&quot;&gt;
    &lt;sofa:binding.bolt&gt;
        &lt;sofa:global-attrs type=&quot;future&quot;/&gt;
    &lt;/sofa:binding.bolt&gt;
&lt;/sofa:reference&gt;
</code></pre><h4 id=annotation-方式>Annotation 方式</h4><p>在 Annotation 方式下，设置 <code>@SofaReferenceBinding</code> 的 <code>invokeType</code> 属性为 <code>future</code> 即可：</p><pre><code class=language-java>@SofaReference(binding = @SofaReferenceBinding(bindingType = &quot;bolt&quot;, invokeType = &quot;future&quot;))
private SampleService sampleService;
</code></pre><h4 id=spring-环境下-api-方式>Spring 环境下 API 方式</h4><p>在 Spring 环境下使用 API，设置 <code>BoltBindingParam</code> 的 <code>type</code> 属性即可：</p><pre><code class=language-java>BoltBindingParam boltBindingParam = new BoltBindingParam();
boltBindingParam.setType(&quot;future&quot;);
</code></pre><h4 id=在非-spring-环境下-api-方式>在非 Spring 环境下 API 方式</h4><p>在非 Spring 环境下使用 SOFARPC 裸 API，设置 <code>ConsumerConfig</code> 的 <code>invokeType</code> 属性即可：</p><pre><code class=language-java>ConsumerConfig&lt;SampleService&gt; consumerConfig = new ConsumerConfig&lt;SampleService&gt;()
    .setInterfaceId(SampleService.class.getName())
    .setRegistry(registryConfig)
    .setProtocol(&quot;bolt&quot;)
    .setInvokeType(&quot;future&quot;);
</code></pre><h4 id=获取调用结果>获取调用结果</h4><p>使用异步调用的方式，目前提供了两种方式来获取异步调用的结果：</p><h5 id=直接获取结果>直接获取结果</h5><p>用户可以通过以下的方式来直接获取异步调用的结果：</p><pre><code class=language-java>String result = (String)SofaResponseFuture.getResponse(0, true);
</code></pre><p>其中第一个参数是获取结果的超时时间，第二个参数表示是否清除线程上下文中的结果。</p><h5 id=获取-jdk-原生-future>获取 JDK 原生 Future</h5><p>用户可以通过以下的方式来获取 JDK 的原生的 Future 对象，再可以从任意地方去调用这个 Future 对象来获取结果：</p><pre><code class=language-java>Future future = SofaResponseFuture.getFuture(true);
</code></pre><p>其中的第一个参数表示是否清除线程上下文中的结果。</p><h3 id=回调>回调</h3><p>SOFARPC Bolt 协议的回调方式可以让 SOFARPC 在发起调用后不等待结果，在客户端收到服务端返回的结果后，自动回调用户实现的一个回调接口。</p><p>使用 SOFARPC Bolt 协议的回调方式，首先需要实现一个回调接口，并且在对应的配置中设置回调接口，再将调用方式设置为 <code>callback</code>。</p><h4 id=实现回调接口>实现回调接口</h4><p>SOFARPC 提供了一个回调的接口 <code>com.alipay.sofa.rpc.core.invoke.SofaResponseCallback</code>，用户使用 SOFARPC Bolt 协议的回调方式，首先需要实现这个接口，该接口提供了三个方法：</p><ul><li><code>onAppResponse</code>：当客户端接收到服务端的正常返回的时候，SOFARPC 会回调这个方法。</li><li><code>onAppException</code>：当客户端接收到服务端的异常响应的时候，SOFARPC 会回调这个方法。</li><li><code>onSofaException</code>：当 SOFARPC 本身出现一些错误，比如路由错误的时候，SOFARPC 会回调这个方法。</li></ul><h4 id=设置回调接口>设置回调接口</h4><p>实现回调接口之后，用户需要将实现类设置到对应的服务引用配置中，并且将调用方式设置为 callback。</p><p>SOFARPC 为设置回调接口提供了两种方式，分别为 Callback Class 和 Callback Ref。Callback Class 的方式直接设置回调的类名，SOFARPC 会通过调用回调类的默认构造函数的方式生成回调类的实例。Callback Ref 的方式则为用户直接提供回调类的实例。</p><h5 id=xml-方式-1>XML 方式</h5><p>如果通过 XML 的方式引用服务，将 <code>&lt;sofa:global-attrs&gt;</code> 标签的 <code>type</code> 属性设置为 <code>callback</code>，并且设置 <code>callback-ref</code> 或者 <code>callback-class</code> 属性即可：</p><pre><code class=language-xml>&lt;bean id=&quot;sampleCallback&quot; class=&quot;com.example.demo.SampleCallback&quot;/&gt;
&lt;sofa:reference interface=&quot;com.example.demo.SampleService&quot; id=&quot;sampleService&quot;&gt;
    &lt;sofa:binding.bolt&gt;
        &lt;sofa:global-attrs type=&quot;callback&quot; callback-ref=&quot;sampleCallback&quot;/&gt;
    &lt;/sofa:binding.bolt&gt;
&lt;/sofa:reference&gt;
</code></pre><p>在 XML 的方式下，<code>callback-ref</code> 的值需要是回调类的 Bean 名称。</p><h5 id=annotation-方式-1>Annotation 方式</h5><p>如果通过 Annotation 的方式引用服务，设置 <code>@SofaReferenceBinding</code> 注解的 <code>invokeType</code> 属性为 <code>callback</code>，并且设置 <code>callbackClass</code> 或者 <code>callbackRef</code> 属性即可：</p><pre><code class=language-java>@SofaReference(binding = @SofaReferenceBinding(bindingType = &quot;bolt&quot;,
            invokeType = &quot;callback&quot;,
            callbackRef = &quot;sampleCallback&quot;))
private SampleService sampleService;
</code></pre><p>在 Annotation 的方式下，<code>callbackRef</code> 属性的值需要是回调类的 Bean 名称。</p><h5 id=spring-环境-api-方式>Spring 环境 API 方式</h5><p>如果在 Spring 或者 Spring Boot 的环境下使用 API 的方式，设置 <code>BoltBindingParam</code> 的 <code>type</code> 属性为 <code>callback</code>，并且设置 <code>callbackClass</code> 或者 <code>callbackRef</code> 属性即可：</p><pre><code class=language-java>BoltBindingParam boltBindingParam = new BoltBindingParam();
boltBindingParam.setType(&quot;callback&quot;);
boltBindingParam.setCallbackClass(&quot;com.example.demo.SampleCallback&quot;);
</code></pre><h5 id=非-spring-环境下-api-方式>非 Spring 环境下 API 方式</h5><p>如果在非 Spring 环境下使用 SOFARPC 的裸 API，调用 <code>setInvokeType</code> 将类型设置成 <code>callback</code>，并且调用 <code>setOnReturn</code> 设置回调类即可：</p><pre><code class=language-java>ConsumerConfig&lt;SampleService&gt; consumerConfig = new ConsumerConfig&lt;SampleService&gt;()
    .setInterfaceId(SampleService.class.getName())
    .setRegistry(registryConfig)
    .setProtocol(&quot;bolt&quot;)
    .setInvokeType(&quot;callback&quot;)
    .setOnReturn(new SampleCallback());
</code></pre><h5 id=在调用级别设置回调接口>在调用级别设置回调接口</h5><p>除了在服务级别设置回调接口之外，还可以在调用级别设置回调接口，方式如下：</p><pre><code class=language-java>RpcInvokeContext.getContext().setResponseCallback(new SampleCallback());
</code></pre><h3 id=单向>单向</h3><p>当客户端发送请求后不关心服务端返回的结果时，可以使用单向的调用方式，这种方式会在发起调用后立即返回 null，并且忽略服务端的返回结果。</p><p>使用单向的方式只需要将调用方式设置为 <code>oneway</code> 即可，设置方式和将调用方式设置为 <code>future</code> 或者 <code>callback</code> 一样，这里不再重复讲述，可以参考上面的文档中提供的设置方式。</p><p>需要特别注意的是，由于单向的调用方式会立即返回，所以所有的超时设置在单向的情况下都是无效的。</p></article></main></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/shuaiqiyu>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/community>社区</a>
<a class=link href=/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/projects/soul/overview/>Soul</a>
<a class=link href=/projects/hmily/overview/>Hmily</a>
<a class=link href=/projects/raincat/overview/>Raincat</a>
<a class=link href=/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>